/* eslint no-use-before-define: 0 */
/**
 * Flowtype definitions for phaser
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.0.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 */

import { PIXI } from 'pixi';
import { p2 } from 'p2';

declare module 'phaser-ce' {
  declare module.exports: $Exports<'Phaser'>;
}
declare module 'Phaser' {
  declare type MSPointerEvent = Object;
  declare type XMLDocument = Object;
  declare type Physics$Ninja$TileType =
    | 'TYPE_EMPTY'
    | 'TYPE_FULL'
    | 'TYPE_45DEG'
    | 'TYPE_CONCAVE'
    | 'TYPE_CONVEX'
    | 'TYPE_22DEGs'
    | 'TYPE_22DEGb'
    | 'TYPE_67DEGs'
    | 'TYPE_67DEGb'
    | 'TYPE_HALF';

  declare type Any$Body =
    | Physics$Arcade$Body
    | Physics$P2$Body
    | Physics$Ninja$Body
    | any;

  declare class Game {
    constructor(
      width?: number | string,
      height?: number | string,
      renderer?: number,
      parent?: any,
      state?: any,
      transparent?: boolean,
      antialias?: boolean,
      physicsConfig?: any,
    ): this,
    constructor(config: IGameConfig): this,
    add: GameObjectFactory,
    antialias: boolean,
    cache: Cache,
    camera: Camera,
    canvas: HTMLCanvasElement,
    clearBeforeRender: boolean,
    config: IGameConfig,
    context: CanvasRenderingContext2D,
    count: number,
    create: Create,
    debug: Utils$Debug,
    device: Device,
    forceSingleUpdate: boolean,
    fpsProblemNotifier: Signal,
    height: number,
    id: number,
    input: Input,
    isBooted: boolean,
    isRunning: boolean,
    load: Loader,
    lockRender: boolean,
    make: GameObjectCreator,
    math: Math,
    net: Net,
    onBlur: Signal,
    onFocus: Signal,
    onPause: Signal,
    onResume: Signal,
    parent: HTMLElement,
    particles: Particles,
    paused: boolean,
    pendingStep: boolean,
    physics: Physics,
    physicsConfig: any,
    plugins: PluginManager,
    preserveDrawingBuffer: Boolean,
    raf: RequestAnimationFrame,
    renderer: PIXI.CanvasRenderer | PIXI.WebGLRenderer,
    renderType: number,
    resolution: number,
    rnd: RandomDataGenerator,
    scale: ScaleManager,
    scratch: BitmapData,
    sound: SoundManager,
    stage: Stage,
    state: StateManager,
    stepCount: number,
    stepping: boolean,
    time: Time,
    transparent: boolean,
    tweens: TweenManager,
    currentUpdateID: number,
    updatesThisFrame: number,
    width: number,
    world: World,
    boot(): void,
    destroy(): void,
    disableStep(): void,
    enableStep(): void,
    focusGain(event: any): void,
    focusLoss(event: any): void,
    gamePaused(event: any): void,
    gameResumed(event: any): void,
    parseConfig(config: any): void,
    removeFromDOM(canvas: HTMLCanvasElement): void,
    setUpRenderer(): void,
    showDebugHeader(): void,
    step(): void,
    update(time: number): void,
    updateLogic(timeStep: number): void,
    updateRender(timeStep: number): void,
  }

  declare var VERSION: string;
  declare var DEV_VERSION: string;
  declare var GAMES: Game[];
  declare var AUTO: number;
  declare var CANVAS: number;
  declare var WEBGL: number;
  declare var HEADLESS: number;
  declare var WEBGL_MULTI: number;
  declare var BITMAPDATA: number;
  declare var BITMAPTEXT: number;
  declare var BUTTON: number;
  declare var CANVAS_FILTER: number;
  declare var CIRCLE: number;
  declare var ELLIPSE: number;
  declare var EMITTER: number;
  declare var GRAPHICS: number;
  declare var GROUP: number;
  declare var IMAGE: number;
  declare var LINE: number;
  declare var MATRIX: number;
  declare var POINT: number;
  declare var POINTER: number;
  declare var POLYGON: number;
  declare var RECTANGLE: number;
  declare var ROUNDEDRECTANGLE: number;
  declare var RENDERTEXTURE: number;
  declare var RETROFONT: number;
  declare var SPRITE: number;
  declare var SPRITEBATCH: number;
  declare var TEXT: number;
  declare var TILEMAP: number;
  declare var TILEMAPLAYER: number;
  declare var TILESPRITE: number;
  declare var WEBGL_FILTER: number;
  declare var ROPE: number;
  declare var CREATURE: number;
  declare var VIDEO: number;
  declare var NONE: number;
  declare var LEFT: number;
  declare var RIGHT: number;
  declare var UP: number;
  declare var DOWN: number;
  declare var HORIZONTAL: number;
  declare var VERTICAL: number;
  declare var LANDSCAPE: number;
  declare var PORTRAIT: number;
  declare var ANGLE_UP: number;
  declare var ANGLE_DOWN: number;
  declare var ANGLE_LEFT: number;
  declare var ANGLE_RIGHT: number;
  declare var ANGLE_NORTH_EAST: number;
  declare var ANGLE_NORTH_WEST: number;
  declare var ANGLE_SOUTH_EAST: number;
  declare var ANGLE_SOUTH_WEST: number;
  declare var TOP_LEFT: number;
  declare var TOP_CENTER: number;
  declare var TOP_RIGHT: number;
  declare var LEFT_TOP: number;
  declare var LEFT_CENTER: number;
  declare var LEFT_BOTTOM: number;
  declare var CENTER: number;
  declare var RIGHT_TOP: number;
  declare var RIGHT_CENTER: number;
  declare var RIGHT_BOTTOM: number;
  declare var BOTTOM_LEFT: number;
  declare var BOTTOM_CENTER: number;
  declare var BOTTOM_RIGHT: number;

  declare class Animation {
    constructor(
      game: Game,
      parent: Sprite,
      name: string,
      frameData: FrameData,
      frames: number[] | string[],
      frameRate?: number,
      loop?: boolean,
    ): this,
    currentFrame: Frame,
    delay: number,
    enableUpdate: boolean,
    frame: number,
    frameTotal: number,
    game: Game,
    isFinished: boolean,
    isPaused: boolean,
    isPlaying: boolean,
    killOnComplete: boolean,
    loop: boolean,
    loopCount: number,
    name: string,
    onComplete: Signal,
    onLoop: Signal,
    onStart: Signal,
    onUpdate: Signal,
    paused: boolean,
    reversed: boolean,
    speed: number,
    complete(): void,
    destroy(): void,
    generateFrameNames(
      prefix: string,
      start: number,
      stop: number,
      suffix?: string,
      zeroPad?: number,
    ): string[],
    next(quantity?: number): void,
    onPause(): void,
    onResume(): void,
    play(
      frameRate?: number,
      loop?: boolean,
      killOnComplete?: boolean,
    ): Animation,
    previous(quantity?: number): void,
    restart(): void,
    reverse(): Animation,
    reverseOnce(): Animation,
    setFrame(frameId?: string | number, useLocalFrameIndex?: boolean): void,
    stop(resetFrame?: boolean, dispatchComplete?: boolean): void,
    update(): boolean,
    updateCurrentFrame(signalUpdate: boolean, fromPlay?: boolean): boolean,
    updateFrameData(frameData: FrameData): void,
  }

  declare class AnimationManager {
    constructor(sprite: Sprite): this,
    currentAnim: Animation,
    currentFrame: Frame,
    frame: number,
    frameData: FrameData,
    frameName: string,
    frameTotal: number,
    game: Game,
    isLoaded: boolean,
    name: string,
    paused: boolean,
    sprite: Sprite,
    updateIfVisible: boolean,
    add(
      name: string,
      frames?: number[] | string[],
      frameRate?: number,
      loop?: boolean,
      useNumericIndex?: boolean,
    ): Animation,
    copyFrameData(frameData: FrameData, frame: string | number): boolean,
    destroy(): void,
    getAnimation(name: string): Animation,
    next(quantity?: number): void,
    play(
      name: string,
      frameRate?: number,
      loop?: boolean,
      killOnComplete?: boolean,
    ): Animation,
    previous(quantity?: number): void,
    stop(name?: string, resetFrame?: boolean): void,
    update(): boolean,
    validateFrames(frames: Frame[], useNumericIndex?: boolean): boolean,
  }

  declare class AnimationParser {
    JSONData(game: Game, json: any): FrameData,
    JSONDataHash(game: Game, json: any): FrameData,
    JSONDataPyxel(game: Game, json: any): FrameData,
    spriteSheet(
      game: Game,
      key: string,
      frameWidth: number,
      frameHeight: number,
      frameMax?: number,
      margin?: number,
      spacing?: number,
      skipFrames?: number,
    ): FrameData,
    XMLData(game: Game, xml: any): FrameData,
  }

  declare class AudioSprite {
    constructor(game: Game, key: string): this,
    game: Game,
    key: string,
    config: any,
    autoplayKey: string,
    autoplay: boolean,
    sounds: any,
    get(marker: string): Sound,
    play(marker: string, volume?: number): Sound,
    stop(marker: string): Sound,
  }

  declare class ArraySet {
    constructor(list: any[]): this,
    position: number,
    list: any[],
    total: number,
    first: any,
    next: any,
    add(item: any): any,
    getByKey(property: string, value: any): any,
    getIndex(item: any): number,
    exists(item: any): boolean,
    reset(): void,
    remove(item: any): any,
    removeAll(destoy?: boolean): void,
    setAll(key: any, value: any): void,
    callAll(key: string, ...parameter: any[]): void,
  }

  declare class ArrayUtils {
    getRandomItem<T>(objects: T[], startIndex?: number, length?: number): T,
    removeRandomItem<T>(objects: T[], startIndex?: number, length?: number): T,
    shuffle<T>(array: T[]): T[],
    transposeMatrix<T>(array: T[]): T,
    rotateMatrix(matrix: any, direction: number | string): any,
    findClosest(value: number, arr: number[]): number,
    rotate(array: any[]): any,
    rotateLeft(array: any[]): any,
    rotateRight(array: any[]): any,
    numberArray(start: number, end: number): number[],
    numberArrayStep(start: number, end?: number, step?: number): number[],
  }

  declare interface BitmapFont {
    base: PIXI.BaseTexture,
    data: HTMLImageElement,
    font: BMFont,
    url: string,
  }

  declare interface BMFont {
    chars: BMFontChar[],
    font: string,
    lineHeight: number,
    size: number,
  }

  declare interface BMFontChar {
    x: number,
    y: number,
    width: number,
    height: number,
    xOffset: number,
    yOffset: number,
    xAdvance: number,
    kerning: number[],
    texture: PIXI.BaseTexture,
  }

  declare class BitmapData {
    constructor(
      game: Game,
      key: string,
      width?: number,
      height?: number,
      skipPool?: boolean,
    ): this,
    baseTexture: PIXI.BaseTexture,
    buffer: ArrayBuffer,
    canvas: HTMLCanvasElement,
    context: CanvasRenderingContext2D,
    ctx: CanvasRenderingContext2D,
    data: Uint8Array,
    dirty: boolean,
    disableTextureUpload: boolean,
    game: Game,
    height: number,
    imageData: ImageData,
    key: string,
    op: string,
    pixels: Uint32Array,
    smoothed: boolean,
    smoothProperty: string,
    texture: PIXI.Texture,
    textureFrame: Frame,
    type: number,
    width: number,
    getTransform(
      translateX: number,
      translateY: number,
      scaleX: number,
      scaleY: number,
      skewX: number,
      skewY: number,
    ): any,
    add(object: any): BitmapData,
    addToWorld(
      x?: number,
      y?: number,
      anchorX?: number,
      anchorY?: number,
      scaleX?: number,
      scaleY?: number,
    ): Image,
    alphaMask(
      source: any,
      mask?: any,
      sourceRect?: Rectangle,
      maskRect?: Rectangle,
    ): BitmapData,
    blendAdd(): BitmapData,
    blendColor(): BitmapData,
    blendColorBurn(): BitmapData,
    blendColorDodge(): BitmapData,
    blendDarken(): BitmapData,
    blendDestinationAtop(): BitmapData,
    blendDestinationIn(): BitmapData,
    blendDestinationOut(): BitmapData,
    blendDestinationOver(): BitmapData,
    blendDifference(): BitmapData,
    blendExclusion(): BitmapData,
    blendHardLight(): BitmapData,
    blendHue(): BitmapData,
    blendLighten(): BitmapData,
    blendLuminosity(): BitmapData,
    blendMultiply(): BitmapData,
    blendOverlay(): BitmapData,
    blendReset(): BitmapData,
    blendSaturation(): BitmapData,
    blendScreen(): BitmapData,
    blendSoftLight(): BitmapData,
    blendSourceAtop(): BitmapData,
    blendSourceIn(): BitmapData,
    blendSourceOut(): BitmapData,
    blendSourceOver(): BitmapData,
    blendXor(): BitmapData,
    circle(
      x: number,
      y: number,
      radius: number,
      fillStyle?: string,
    ): BitmapData,
    clear(x?: number, y?: number, width?: number, height?: number): BitmapData,
    cls(): BitmapData,
    copy(
      source?: any,
      x?: number,
      y?: number,
      width?: number,
      height?: number,
      tx?: number,
      ty?: number,
      newWidth?: number,
      newHeight?: number,
      rotate?: number,
      anchorX?: number,
      anchorY?: number,
      scaleX?: number,
      scaleY?: number,
      alpha?: number,
      blendMode?: string,
      roundPx?: boolean,
    ): BitmapData,
    copyPixels(
      source: any,
      area: Rectangle,
      x: number,
      y: number,
      alpha?: number,
    ): void,
    copyRect(
      source: any,
      area: Rectangle,
      x?: number,
      y?: number,
      alpha?: number,
      blendMode?: string,
      roundPx?: boolean,
    ): BitmapData,
    copyTransform(
      source: any,
      blendMode?: string,
      roundPx?: boolean,
    ): BitmapData,
    destroy(): void,
    draw(
      source: any,
      x?: number,
      y?: number,
      width?: number,
      height?: number,
      blendMode?: string,
      roundPx?: boolean,
    ): BitmapData,
    drawFull(parent: any, blendMode?: string, roundPx?: boolean): BitmapData,
    drawGroup(group: Group, blendMode?: string, roundPx?: boolean): BitmapData,
    extract(
      destination: BitmapData,
      r: number,
      g: number,
      b: number,
      a?: number,
      resize?: boolean,
      r2?: number,
      g2?: number,
      b2?: number,
    ): BitmapData,
    fill(r: number, g: number, b: number, a?: number): BitmapData,
    generateTexture(key: string): PIXI.Texture,
    getBounds(rect?: Rectangle): Rectangle,
    getFirstPixel(direction: number): {
      r: number,
      g: number,
      b: number,
      x: number,
      y: number,
    },
    getPixel(x: number, y: number, out?: any): any,
    getPixelRGB(
      x: number,
      y: number,
      out?: any,
      hsl?: boolean,
      hsv?: boolean,
    ): any,
    getPixel32(x: number, y: number): number,
    getPixels(rect: Rectangle): ImageData,
    getTransform(
      translateX: number,
      translateY: number,
      scaleX: number,
      scaleY: number,
      skewX: number,
      skewY: number,
    ): any,
    line(
      x1: number,
      y1: number,
      x2: number,
      y2: number,
      color?: string,
      width?: number,
    ): BitmapData,
    load(source: any): BitmapData,
    move(x: number, y: number, wrap?: boolean): BitmapData,
    moveH(distance: number, wrap?: boolean): BitmapData,
    moveV(distance: number, wrap?: boolean): BitmapData,
    processPixel(
      callback: (color: number, x: number, y: number) => void,
      callbackContext: any,
      x?: number,
      y?: Number,
      width?: number,
      height?: number,
    ): BitmapData,
    processPixelRGB(
      callback: (color: ColorComponents, x: number, y: number) => void,
      callbackContext: any,
      x?: number,
      y?: Number,
      width?: number,
      height?: number,
    ): BitmapData,
    rect(
      x: number,
      y: number,
      width: number,
      height: number,
      fillStyle?: string,
    ): BitmapData,
    render(): BitmapData,
    replaceRGB(
      r1: number,
      g1: number,
      b1: number,
      a1: number,
      r2: number,
      g2: number,
      b2: number,
      a2: number,
      region?: Rectangle,
    ): BitmapData,
    resize(width: number, height: number): BitmapData,
    resizeFrame(parent: any, width: number, height: number): void,
    setHSL(h?: number, s?: number, l?: number, region?: Rectangle): BitmapData,
    setPixel(
      x: number,
      y: number,
      red: number,
      green: number,
      blue: number,
      immediate?: boolean,
    ): BitmapData,
    setPixel32(
      x: number,
      y: number,
      red: number,
      green: number,
      blue: number,
      alpha: number,
      immediate?: boolean,
    ): BitmapData,
    shadow(color: string, blur?: number, x?: number, y?: number): BitmapData,
    shiftHSL(
      h?: number,
      s?: number,
      l?: number,
      region?: Rectangle,
    ): BitmapData,
    text(
      text: string,
      x?: number,
      y?: number,
      font?: string,
      color?: string,
      shadow?: boolean,
    ): BitmapData,
    textureLine(line: Line, key: string, repeat?: string): BitmapData,
    update(x?: number, y?: number, width?: number, height?: number): BitmapData,
  }

  declare class BitmapText extends PIXI.DisplayObjectContainer {
    constructor(
      game: Game,
      x: number,
      y: number,
      font: string,
      text?: string,
      size?: number,
      align?: string,
    ): this,
    align: string,
    alive: boolean,
    anchor: Point,
    animations: AnimationManager,
    angle: number,
    autoCull: boolean,
    body: Any$Body,
    bottom: number,
    cameraOffset: Point,
    checkWorldBounds: boolean,
    data: any,
    destroyPhase: boolean,
    debug: boolean,
    dirty: boolean,
    events: Events,
    exists: boolean,
    fixedToCamera: boolean,
    font: string,
    fontSize: number,
    fresh: boolean,
    game: Game,
    input: InputHandler,
    inputEnabled: boolean,
    inCamera: boolean,
    inWorld: boolean,
    key: string | RenderTexture | BitmapData | Video | PIXI.Texture,
    left: number,
    name: string,
    components: any,
    lifespan: number,
    maxWidth: number,
    offsetX: number,
    offsetY: number,
    outOfBoundsKill: boolean,
    pendingDestroy: boolean,
    physicsType: number,
    previousPosition: Point,
    previousRotation: number,
    position: Point,
    renderOrderID: number,
    right: number,
    text: string,
    smoothed: boolean,
    textWidth: number,
    textHeight: number,
    tint: number,
    top: number,
    type: number,
    world: Point,
    x: number,
    y: number,
    z: number,
    alignIn(
      container:
        | Rectangle
        | Sprite
        | Image
        | Text
        | BitmapText
        | Button
        | Graphics
        | TileSprite,
      position?: number,
      offsetX?: number,
      offsetY?: number,
    ): any,
    alignTo(
      container:
        | Rectangle
        | Sprite
        | Image
        | Text
        | BitmapText
        | Button
        | Graphics
        | TileSprite,
      position?: number,
      offsetX?: number,
      offsetY?: number,
    ): any,
    destroy(destroyChildren?: boolean): void,
    kill(): void,
    postUpdate(): void,
    preUpdate(): void,
    purgeGlyphs(): number,
    reset(x: number, y: number, health?: number): BitmapText,
    revive(health?: number): BitmapText,
    scanLine(data: any, scale: number, text: string): {
      width: number,
      text: string,
      end: boolean,
      chars: string[],
    },
    setText(text: string): void,
    update(): void,
    updateText(): void,
    updateTransform(): void,
  }

  declare class Bullet extends Sprite {
    constructor(game: Game, x: number, y: number, key?: any, frame?: any): this,
    kill(): Bullet,
    update(): void,
  }

  declare class Button extends Image {
    constructor(
      game: Game,
      x?: number,
      y?: number,
      key?: string,
      callback?: Function,
      callbackContext?: any,
      overFrame?: string | number,
      outFrame?: string | number,
      downFrame?: string | number,
      upFrame?: string | number,
    ): this,
    forceOut: boolean,
    freezeFrames: boolean,
    onDownSound: Sound | AudioSprite,
    onDownSoundMarker: string,
    onInputDown: Signal,
    onInputOut: Signal,
    onInputOver: Signal,
    onInputUp: Signal,
    onOutSound: Sound | AudioSprite,
    onOutSoundMarker: string,
    onOverSound: Sound | AudioSprite,
    onOverSoundMarker: string,
    onOverMouseOnly: boolean,
    onUpSound: Sound | AudioSprite,
    onUpSoundMaker: string,
    physicsType: number,
    type: number,
    clearFrames(): void,
    setDownSound(sound: Sound | AudioSprite, marker?: string): void,
    setFrames(
      overFrame?: string | number,
      outFrame?: string | number,
      downFrame?: string | number,
      upFrame?: string | number,
    ): void,
    onInputOverHandler(sprite: Button, pointer: Pointer): void,
    onInputOutHandler(sprite: Button, pointer: Pointer): void,
    onInputDownHandler(sprite: Button, pointer: Pointer): void,
    onInputUpHandler(sprite: Button, pointer: Pointer, isOver: boolean): void,
    removedFromWorld(): void,
    setOutSound(sound: Sound | AudioSprite, marker?: string): void,
    setOverSound(sound: Sound | AudioSprite, marker?: string): void,
    setSounds(
      overSound?: Sound | AudioSprite,
      overMarker?: string,
      downSound?: Sound | AudioSprite,
      downMarker?: string,
      outSound?: Sound | AudioSprite,
      outMarker?: string,
      upSound?: Sound | AudioSprite,
      upMarker?: string,
    ): void,
    setState(newState: number): void,
    setUpSound(sound: Sound | AudioSprite, marker?: string): void,
  }

  declare class PointerMode {
    CURSOR: number,
    CONTACT: number,
  }

  declare class Cache {
    constructor(game: Game): this,
    BINARY: number,
    BITMAPDATA: number,
    BITMAPFONT: number,
    CANVAS: number,
    IMAGE: number,
    JSON: number,
    PHYSICS: number,
    RENDER_TEXTURE: number,
    SHADER: number,
    SOUND: number,
    SPRITE_SHEET: number,
    TEXT: number,
    TEXTURE: number,
    TEXTURE_ATLAS: number,
    TILEMAP: number,
    XML: number,
    VIDEO: number,
    DEFAULT: PIXI.Texture,
    MISSING: PIXI.Texture,
    autoResolveURL: boolean,
    game: Game,
    onSoundUnlock: Signal,
    addBinary(key: string, binaryData: any): void,
    addBitmapData(
      key: string,
      bitmapData: BitmapData,
      frameData?: FrameData,
    ): BitmapData,
    addBitmapFont(
      key: string,
      url: string,
      data: any,
      atlasData: any,
      atlasType: string,
      xSpacing?: number,
      ySpacing?: number,
    ): void,
    addBitmapFontFromAtlas(
      key: string,
      atlasKey: string,
      atlasFrame: string,
      dataKey: string,
      dataType?: string,
      xSpacing?: number,
      ySpacing?: number,
    ): void,
    addCanvas(
      key: string,
      canvas: HTMLCanvasElement,
      context?: CanvasRenderingContext2D,
    ): void,
    addDefaultImage(): void,
    addImage(key: string, url: string, data: any): HTMLImageElement,
    addJSON(key: string, urL: string, data: any): void,
    addMissingImage(): void,
    addPhysicsData(
      key: string,
      url: string,
      JSONData: any,
      format: number,
    ): void,
    addRenderTexture(key: string, texture: RenderTexture): void,
    addShader(key: string, url: string, data: any): void,
    addSound(
      key: string,
      url: string,
      data: any,
      webAudio: boolean,
      audioTag: boolean,
    ): void,
    addSpriteSheet(
      key: string,
      url: string,
      data: any,
      frameWidth: number,
      frameHeight: number,
      frameMax?: number,
      margin?: number,
      spacing?: number,
      skipFrames?: number,
    ): void,
    addText(key: string, url: string, data: any): void,
    addTextureAtlas(
      key: string,
      url: string,
      data: any,
      atlasData: any,
      format: number,
    ): void,
    addTilemap(key: string, url: string, mapData: any, format: number): void,
    addVideo(key: string, url: string, data: any, isBlob?: boolean): void,
    addXML(key: string, url: string, data: any): void,
    checkBinaryKey(key: string): boolean,
    checkBitmapDataKey(key: string): boolean,
    checkBitmapFontKey(key: string): boolean,
    checkCanvasKey(key: string): boolean,
    checkImageKey(key: string): boolean,
    checkJSONKey(key: string): boolean,
    checkKey(cache: number, key: string): boolean,
    checkPhysicsKey(key: string): boolean,
    checkRenderTextureKey(key: string): boolean,
    checkShaderKey(key: string): boolean,
    checkSoundKey(key: string): boolean,
    checkTextKey(key: string): boolean,
    checkTextureKey(key: string): boolean,
    checkTilemapKey(key: string): boolean,
    checkURL(url: string): any,
    checkUrl(url: string): any,
    checkXMLKey(key: string): boolean,
    checkVideoKey(key: string): boolean,
    clearGLTextures(): void,
    decodedSound(key: string, data: any): void,
    destroy(): void,
    getBaseTexture(key: string, cache?: number): PIXI.BaseTexture,
    getBinary(key: string): any,
    getBitmapData(key: string): BitmapData,
    getBitmapFont(key: string): BitmapFont,
    getCanvas(key: string): HTMLCanvasElement,
    getFrame(key: string, cache?: number): Frame,
    getFrameByIndex(key: string, index: number, cache?: number): Frame,
    getFrameByName(key: string, name: string, cache?: number): Frame,
    getFrameCount(key: string, cache?: number): number,
    getFrameData(key: string, cache?: number): FrameData,
    getImage(key: string, full?: boolean): HTMLImageElement,
    getItem(
      key: string,
      cache: number,
      method?: string,
      property?: string,
    ): any,
    getJSON(key: string, clone?: boolean): any,
    getKeys(cache: number): string[],
    getPhysicsData(key: string, object?: string, fixtureKey?: string): any[],
    getRenderTexture(key: string): CachedRenderTexture,
    getShader(key: string): string,
    getSound(key: string): Sound,
    getSoundData(key: string): any,
    getSpriteSheetKey(key: string): boolean,
    getText(key: string): string,
    getTextKeys(): string[],
    getTexture(key: string): RenderTexture,
    getTextureAtlasKey(key: string): boolean,
    getTextureFrame(key: string): Frame,
    getTilemap(key: string): any,
    getTilemapData(key: string): any,
    getURL(url: string): any,
    getXML(key: string): any,
    getVideo(key: string): Video,
    hasFrameData(key: string, cache?: number): boolean,
    isSoundDecoded(key: string): boolean,
    isSoundReady(key: string): boolean,
    isSpriteSheet(key: string): boolean,
    reloadSound(key: string): void,
    reloadSoundComplete(key: string): void,
    removeBinary(key: string): void,
    removeBitmapData(key: string): void,
    removeBitmapFont(key: string): void,
    removeCanvas(key: string): void,
    removeImage(key: string, removeFromPixi?: boolean): void,
    removeJSON(key: string): void,
    removePhysics(key: string): void,
    removeRenderTexture(key: string): void,
    removeShader(key: string): void,
    removeSound(key: string): void,
    removeSpriteSheet(key: string): void,
    removeText(key: string): void,
    removeTextureAtlas(key: string): void,
    removeTilemap(key: string): void,
    removeXML(key: string): void,
    removeVideo(key: string): void,
    updateFrameData(key: string, frameData: any, cache?: number): void,
    updateSound(key: string, property: string, value: Sound): void,
  }

  declare interface CachedRenderTexture {
    frame: Frame,
    texture: RenderTexture,
  }

  declare class Camera {
    constructor(
      game: Game,
      id: number,
      x: number,
      y: number,
      width: number,
      height: number,
    ): this,
    FOLLOW_LOCKON: number,
    FOLLOW_PLATFORMER: number,
    FOLLOW_TOPDOWN: number,
    FOLLOW_TOPDOWN_TIGHT: number,
    SHAKE_BOTH: number,
    SHAKE_HORIZONTAL: number,
    SHAKE_VERTICAL: number,
    ENABLE_FX: number,
    atLimit: {
      x: boolean,
      y: boolean,
    },
    bounds: Rectangle,
    deadzone: Rectangle,
    displayObject: PIXI.DisplayObject,
    id: number,
    fx: Graphics,
    game: Game,
    height: number,
    lerp: Point,
    position: Point,
    roundPx: boolean,
    scale: Point,
    shakeIntensity: number,
    onFadeComplete: Signal,
    onFlashComplete: Signal,
    onShakeComplete: Signal,
    target: Sprite,
    totalInView: number,
    view: Rectangle,
    visible: boolean,
    width: number,
    world: World,
    x: number,
    y: number,
    checkBounds(): void,
    fade(
      color?: number,
      duration?: number,
      force?: boolean,
      alpha?: number,
    ): boolean,
    flash(
      color?: number,
      duration?: number,
      force?: boolean,
      alpha?: number,
    ): boolean,
    focusOn(displayObject: PIXI.DisplayObject): void,
    focusOnXY(x: number, y: number): void,
    follow(
      target: Sprite,
      style?: number,
      lerpX?: number,
      lerpY?: number,
    ): void,
    reset(): void,
    resetFX(): void,
    setBoundsToWorld(): void,
    setPosition(x: number, y: number): void,
    setSize(width: number, height: number): void,
    shake(
      intensity?: number,
      duration?: number,
      force?: boolean,
      direction?: number,
      shakeBounds?: boolean,
    ): boolean,
    unfollow(): void,
    update(): void,
  }

  declare class Canvas {
    addToDOM(
      canvas: HTMLCanvasElement,
      parent: HTMLElement,
      overflowHidden?: boolean,
    ): HTMLCanvasElement,
    create(
      parent: HTMLDivElement,
      width?: number,
      height?: number,
      id?: string,
      skipPool?: boolean,
    ): HTMLCanvasElement,
    getSmoothingEnabled(context: CanvasRenderingContext2D): boolean,
    getSmoothingPrefix(context: CanvasRenderingContext2D): string,
    removeFromDOM(canvas: HTMLCanvasElement): void,
    setBackgroundColor(
      canvas: HTMLCanvasElement,
      color: string,
    ): HTMLCanvasElement,
    setImageRenderingBicubic(canvas: HTMLCanvasElement): HTMLCanvasElement,
    setImageRenderingCrisp(canvas: HTMLCanvasElement): HTMLCanvasElement,
    setSmoothingEnabled(
      context: CanvasRenderingContext2D,
      value: boolean,
    ): CanvasRenderingContext2D,
    setTouchAction(canvas: HTMLCanvasElement, value: string): HTMLCanvasElement,
    setTransform(
      context: CanvasRenderingContext2D,
      translateX: number,
      translateY: number,
      scaleX: number,
      scaleY: number,
      skewX: number,
      skewY: number,
    ): CanvasRenderingContext2D,
    setUserSelect(canvas: HTMLCanvasElement, value?: string): HTMLCanvasElement,
  }

  declare class Circle {
    constructor(x?: number, y?: number, diameter?: number): this,
    area: number,
    bottom: number,
    diameter: number,
    empty: boolean,
    left: number,
    radius: number,
    right: number,
    top: number,
    x: number,
    y: number,
    circumferencePoint(
      a: Circle,
      angle: number,
      asDegrees: boolean,
      out?: Point,
    ): Point,
    contains(a: Circle, x: number, y: number): boolean,
    equals(a: Circle, b: Circle): boolean,
    intersects(a: Circle, b: Circle): boolean,
    intersectsRectangle(c: Circle, r: Rectangle): boolean,
    circumference(): number,
    circumferencePoint(angle: number, asDegrees?: boolean, out?: Point): Point,
    clone(output: Circle): Circle,
    contains(x: number, y: number): boolean,
    copyFrom(source: any): Circle,
    copyTo(dest: any): any,
    distance(dest: any, round?: boolean): number,
    getBounds(): Rectangle,
    offset(dx: number, dy: number): Circle,
    offsetPoint(point: Point): Circle,
    random(out?: Point): Point,
    scale(x: number, y?: number): Rectangle,
    setTo(x: number, y: number, diameter: number): Circle,
    toString(): string,
  }

  declare class Color {
    componentToHex(color: number): string,
    createColor(
      r?: number,
      g?: number,
      b?: number,
      a?: number,
      h?: number,
      s?: number,
      l?: number,
      v?: number,
    ): ColorComponents,
    fromRGBA(rgba: number, out?: ColorComponents): ColorComponents,
    getAlpha(color: number): number,
    getAlphaFloat(color: number): number,
    getBlue(color: number): number,
    getColor(red: number, green: number, blue: number): number,
    getColor32(alpha: number, red: number, green: number, blue: number): number,
    getGreen(color: number): number,
    getRandomColor(min?: number, max?: number, alpha?: number): number,
    getRed(color: number): number,
    getRGB(color: number): RGBColor,
    getWebRGB(color: number | RGBColor): string,
    hexToRGBArray(color: number): number[],
    hexToRGB(h: string): number,
    hexToColor(hex: string, out?: ColorComponents): ColorComponents,
    HSLtoRGB(
      h: number,
      s: number,
      l: number,
      out?: ColorComponents,
    ): ColorComponents,
    HSLColorWheel(s?: number, l?: number): ColorComponents[],
    HSVtoRGB(
      h: number,
      s: number,
      v: number,
      out?: ColorComponents,
    ): ColorComponents,
    HSVColorWheel(s?: number, v?: number): ColorComponents[],
    hueToColor(p: number, q: number, t: number): number,
    interpolateColor(
      color1: number,
      color2: number,
      steps: number,
      currentStep: number,
      alpha?: number,
    ): number,
    interpolateColorWithRGB(
      color: number,
      r: number,
      g: number,
      b: number,
      steps: number,
      currentStep: number,
    ): number,
    interpolateRGB(
      r1: number,
      g1: number,
      b1: number,
      r2: number,
      g2: number,
      b2: number,
      steps: number,
      currentStep: number,
    ): number,
    packPixel(r: number, g: number, b: number, a: number): number,
    RGBArrayToHex(rgb: number[]): number,
    RGBtoHSL(
      r: number,
      g: number,
      b: number,
      out?: ColorComponents,
    ): ColorComponents,
    RGBtoHSV(
      r: number,
      g: number,
      b: number,
      out?: ColorComponents,
    ): ColorComponents,
    RGBtoString(
      r: number,
      g: number,
      b: number,
      a?: number,
      prefix?: string,
    ): string,
    toRGBA(r: number, g: number, b: number, a: number): number,
    toABGR(r: number, g: number, b: number, a: number): number,
    unpackPixel(
      rgba: number,
      out?: ColorComponents,
      hsl?: boolean,
      hsv?: boolean,
    ): ColorComponents,
    updateColor(out: ColorComponents): ColorComponents,
    valueToColor(value: string, out?: ColorComponents): ColorComponents,
    webToColor(web: string, out?: ColorComponents): ColorComponents,
    blendNormal(a: number): number,
    blendLighten(a: number, b: number): number,
    blendDarken(a: number, b: number): number,
    blendMultiply(a: number, b: number): number,
    blendAverage(a: number, b: number): number,
    blendAdd(a: number, b: number): number,
    blendSubtract(a: number, b: number): number,
    blendDifference(a: number, b: number): number,
    blendNegation(a: number, b: number): number,
    blendScreen(a: number, b: number): number,
    blendExclusion(a: number, b: number): number,
    blendOverlay(a: number, b: number): number,
    blendSoftLight(a: number, b: number): number,
    blendHardLight(a: number, b: number): number,
    blendColorDodge(a: number, b: number): number,
    blendColorBurn(a: number, b: number): number,
    blendLinearDodge(a: number, b: number): number,
    blendLinearBurn(a: number, b: number): number,
    blendLinearLight(a: number, b: number): number,
    blendVividLight(a: number, b: number): number,
    blendPinLight(a: number, b: number): number,
    blendHardMix(a: number, b: number): number,
    blendReflect(a: number, b: number): number,
    blendGlow(a: number, b: number): number,
    blendPhoenix(a: number, b: number): number,
  }

  declare interface RGBColor {
    r: number,
    g: number,
    b: number,
    a: number,
  }

  declare type ColorComponents =
    & {
      h: number,
      s: number,
      v: number,
      l: number,
      color: number,
      color32: number,
      rgba: string,
    }
    & RGBColor;

  declare class Create {
    constructor(game: Game): this,
    PALETTE_ARNE: number,
    PALETTE_JMP: number,
    PALETTE_CGA: number,
    PALETTE_C64: number,
    PALETTE_JAPANESE_MACHINE: number,
    bmd: BitmapData,
    canvas: HTMLCanvasElement,
    ctx: CanvasRenderingContext2D,
    game: Game,
    palettes: any,
    grid(
      key: string,
      width: number,
      height: number,
      cellWidth: number,
      cellHeight: number,
      color: string,
    ): PIXI.Texture,
    texture(
      key: string,
      data: any,
      pixelWidth?: number,
      pixelHeight?: number,
      palette?: number,
    ): PIXI.Texture,
  }

  declare interface CursorKeys {
    up: Key,
    down: Key,
    left: Key,
    right: Key,
  }

  declare class Device {
    LITTLE_ENDIAN: boolean,
    onInitialized: Signal,
    checkFullScreenSupport(): void,
    canPlayAudio(type: string): boolean,
    canPlayVideo(type: string): boolean,
    isConsoleOpen(): boolean,
    isAndroidStockBrowser(): string,
    whenReady: (callback: Function, context?: any) => void,
    android: boolean,
    arora: boolean,
    audioData: boolean,
    cancelFullScreen: string,
    canHandleAlpha: boolean,
    canUseMultiply: boolean,
    canvas: boolean,
    chrome: boolean,
    chromeOS: boolean,
    chromeVersion: number,
    cocoonJS: boolean,
    cocoonJSApp: boolean,
    cordova: boolean,
    crosswalk: boolean,
    css3D: boolean,
    desktop: boolean,
    deviceReadyAt: number,
    electron: boolean,
    ejecta: boolean,
    epiphany: boolean,
    file: boolean,
    fileSystem: boolean,
    firefox: boolean,
    firefoxVersion: number,
    fullScreen: boolean,
    fullScreenKeyboard: boolean,
    getUserMedia: boolean,
    game: Game,
    h264Video: boolean,
    hlsVideo: boolean,
    ie: boolean,
    ieVersion: number,
    iOS: boolean,
    iOSVersion: number,
    initialized: boolean,
    iPad: boolean,
    iPhone: boolean,
    iPhone4: boolean,
    kindle: boolean,
    linux: boolean,
    littleEndian: boolean,
    localStorage: boolean,
    m4a: boolean,
    macOS: boolean,
    midori: boolean,
    mobileSafari: boolean,
    mp3: boolean,
    mp4Video: boolean,
    mspointer: boolean,
    node: boolean,
    nodeWebkit: boolean,
    ogg: boolean,
    oggVideo: number,
    opera: boolean,
    opus: boolean,
    pixelRatio: number,
    pointerLock: boolean,
    quirksMode: boolean,
    requestFullScreen: string,
    safari: boolean,
    silk: boolean,
    support32bit: boolean,
    touch: boolean,
    trident: boolean,
    tridentVersion: number,
    typedArray: boolean,
    vibration: boolean,
    vita: boolean,
    wav: boolean,
    webApp: boolean,
    webAudio: boolean,
    webGL: boolean,
    webm: boolean,
    webmVideo: boolean,
    windows: boolean,
    windowsPhone: boolean,
    wheelEvent: string,
    worker: boolean,
    wp9Video: boolean,
  }

  declare class DeviceButton {
    constructor(parent: Pointer | SinglePad, butonCode: number): this,
    buttonCode: number,
    game: Game,
    isDown: boolean,
    isUp: boolean,
    onDown: Signal,
    onFloat: Signal,
    onUp: Signal,
    pad: Gamepad,
    repeats: number,
    timeDown: number,
    timeUp: number,
    value: number,
    destroy(): void,
    justPressed(duration?: number): boolean,
    justReleased(duration?: number): boolean,
    processButtonDown(value: number): void,
    processButtonFloat(value: number): void,
    processButtonUp(value: number): void,
    reset(): void,
  }

  declare var Default: Function;

  declare var Power0: Function;

  declare var Power1: Function;

  declare var power2: Function;

  declare var power3: Function;

  declare var power4: Function;

  declare class Back {
    In(k: number): number,
    Out(k: number): number,
    InOut(k: number): number,
  }

  declare class Bounce {
    In(k: number): number,
    Out(k: number): number,
    InOut(k: number): number,
  }

  declare class Circular {
    In(k: number): number,
    Out(k: number): number,
    InOut(k: number): number,
  }

  declare class Cubic {
    In(k: number): number,
    Out(k: number): number,
    InOut(k: number): number,
  }

  declare class Elastic {
    In(k: number): number,
    Out(k: number): number,
    InOut(k: number): number,
  }

  declare class Exponential {
    In(k: number): number,
    Out(k: number): number,
    InOut(k: number): number,
  }

  declare class Linear {
    None(k: number): number,
  }

  declare class Quadratic {
    In(k: number): number,
    Out(k: number): number,
    InOut(k: number): number,
  }

  declare class Quartic {
    In(k: number): number,
    Out(k: number): number,
    InOut(k: number): number,
  }

  declare class Quintic {
    In(k: number): number,
    Out(k: number): number,
    InOut(k: number): number,
  }

  declare class Sinusoidal {
    In(k: number): number,
    Out(k: number): number,
    InOut(k: number): number,
  }

  declare class Ellipse {
    constructor(x?: number, y?: number, width?: number, height?: number): this,
    bottom: number,
    empty: boolean,
    height: number,
    left: number,
    right: number,
    top: number,
    type: number,
    width: number,
    x: number,
    y: number,
    constains(a: Ellipse, x: number, y: number): boolean,
    clone(output: Ellipse): Ellipse,
    contains(x: number, y: number): boolean,
    copyFrom(source: any): Ellipse,
    copyTo(dest: any): any,
    getBounds(): Rectangle,
    random(out?: Point): Point,
    setTo(x: number, y: number, width: number, height: number): Ellipse,
    toString(): string,
  }

  declare class Events {
    constructor(sprite: Sprite): this,
    parent: Sprite,
    onAddedToGroup: Signal,
    onRemovedFromGroup: Signal,
    onRemovedFromWorld: Signal,
    onKilled: Signal,
    onRevived: Signal,
    onOutOfBounds: Signal,
    onEnterBounds: Signal,
    onInputOver: Signal,
    onInputOut: Signal,
    onInputDown: Signal,
    onInputUp: Signal,
    onDestroy: Signal,
    onDragStart: Signal,
    onDragStop: Signal,
    onDragUpdate: Signal,
    onAnimationStart: Signal,
    onAnimationComplete: Signal,
    onAnimationLoop: Signal,
    destroy(): void,
  }

  declare class Filter extends PIXI.AbstractFilter {
    constructor(
      game: Game,
      uniforms: any,
      fragmentSrc: string | string[],
    ): this,
    dirty: boolean,
    game: Game,
    height: number,
    fragmentSrc: string | string[],
    padding: number,
    prevPoint: Point,
    type: number,
    uniforms: any,
    width: number,
    addToWorld(
      x?: number,
      y?: number,
      width?: number,
      height?: number,
      anchorX?: number,
      anchorY?: number,
    ): Image,
    apply(frameBuffer: WebGLFramebuffer): void,
    destroy(): void,
    init(...args: any[]): void,
    setResolution(width: number, height: number): void,
    syncUniforms(): void,
    update(pointer?: Pointer): void,
  }

  declare class BinarySerpents extends Filter {
    constructor(
      game: Game,
      width: number,
      height: number,
      march?: number,
      maxDistance?: number,
    ): this,
    fog: number,
  }

  declare class BlurX extends Filter {
    blur: number,
  }

  declare class BlurY extends Filter {
    blur: number,
  }

  declare class CausticLight extends Filter {
    constructor(
      game: Game,
      width: number,
      height: number,
      divisor?: number,
    ): this,
    init(width: number, height: number, divisor?: number): void,
  }

  declare class CheckerWave extends Filter {
    constructor(game: Game, width: number, height: number): this,
    alpha: number,
    cameraX: number,
    cameraY: number,
    cameraZ: number,
    init(width: number, height: number): void,
    setColor1(red: number, green: number, blue: number): void,
    setColor2(red: number, green: number, blue: number): void,
  }

  declare class ColorBars extends Filter {
    constructor(game: Game, width: number, height: number): this,
    alpha: number,
    init(width: number, height: number): void,
  }

  declare class Fire extends Filter {
    constructor(
      width: number,
      height: number,
      alpha?: number,
      shift?: number,
    ): this,
    alpha: number,
    shift: number,
    speed: number,
    init(width: number, height: number, alpha?: number, shift?: number): void,
  }

  declare class Gray extends Filter {
    gray: number,
  }

  declare class HueRotate extends Filter {
    constructor(game: Game, width: number, height: number, texture: any): this,
    alpha: number,
    init(width: number, height: number, texture: any): void,
  }

  declare class LazerBeam extends Filter {
    init(width: number, height: number, divisor?: number): void,
  }

  declare class LightBeam extends Filter {
    constructor(game: Game, width: number, height: number): this,
    alpha: number,
    blue: number,
    green: number,
    red: number,
    thickness: number,
    speed: number,
    init(width: number, height: number): void,
  }

  declare class Marble extends Filter {
    constructor(
      game: Game,
      width: number,
      height: number,
      speed?: number,
      intensity?: number,
    ): this,
    alpha: number,
    intensity: number,
    speed: number,
    init(
      width: number,
      height: number,
      speed?: number,
      intensity?: number,
    ): void,
  }

  declare class Pixelate extends Filter {
    size: number,
    sizeX: number,
    sizeY: number,
  }

  declare class Plasma extends Filter {
    constructor(
      game: Game,
      width: number,
      height: number,
      alpha?: number,
      size?: number,
    ): this,
    alpha: number,
    blueShift: number,
    greenShift: number,
    redShift: number,
    size: number,
    init(width: number, height: number, alpha?: number, size?: number): void,
  }

  declare class SampleFilter extends Filter {
    constructor(
      game: Game,
      width: number,
      height: number,
      divisor?: number,
    ): this,
    init(width: number, height: number, divisor?: number): void,
  }

  declare class Tunnel extends Filter {
    constructor(game: Game, width: number, height: number, texture: any): this,
    alpha: number,
    origin: number,
    init(width: number, height: number, texture: any): void,
  }

  declare class FlexGrid {
    constructor(manager: ScaleManager, width: number, height: number): this,
    game: Game,
    manager: ScaleManager,
    width: number,
    height: number,
    boundsCustom: Rectangle,
    boundsFluid: Rectangle,
    boundsFull: Rectangle,
    boundsNone: Rectangle,
    customWidth: number,
    customHeight: number,
    customOffsetX: number,
    customOffsetY: number,
    positionCustom: Point,
    positionFluid: Point,
    positionFull: Point,
    positionNone: Point,
    scaleCustom: Point,
    scaleFluid: Point,
    scaleFluidInversed: Point,
    scaleFull: Point,
    scaleNone: Point,
    ratioH: number,
    ratioV: number,
    multiplier: number,
    createCustomLayer(
      width: number,
      height: number,
      children?: PIXI.DisplayObject[],
      addToWorld?: boolean,
    ): FlexLayer,
    createFluidLayer(children: PIXI.DisplayObject[]): FlexLayer,
    createFullLayer(children: PIXI.DisplayObject[]): FlexLayer,
    createFixedLayer(children: PIXI.DisplayObject[]): FlexLayer,
    debug(): void,
    fitSprite(sprite: Sprite): void,
    onResize(width: number, height: number): void,
    refresh(): void,
    reset(): void,
    setSize(width: number, height: number): void,
  }

  declare class FlexLayer extends Group {
    constructor(
      manager: ScaleManager,
      position: Point,
      bounds: Rectangle,
      scale: Point,
    ): this,
    grid: FlexGrid,
    manager: ScaleManager,
    bottomLeft: Point,
    bottomMiddle: Point,
    bottomRight: Point,
    bounds: Rectangle,
    persist: boolean,
    position: Point,
    scale: Point,
    topLeft: Point,
    topMiddle: Point,
    topRight: Point,
    debug(): void,
    resize(): void,
  }

  declare class Frame {
    constructor(
      index: number,
      x: number,
      y: number,
      width: number,
      height: number,
      name: string,
    ): this,
    bottom: number,
    centerX: number,
    centerY: number,
    distance: number,
    height: number,
    index: number,
    name: string,
    right: number,
    rotated: boolean,
    sourceSizeH: number,
    sourceSizeW: number,
    spriteSourceSizeH: number,
    spriteSourceSizeW: number,
    spriteSourceSizeX: number,
    spriteSourceSizeY: number,
    trimmed: boolean,
    uuid: string,
    width: number,
    x: number,
    y: number,
    clone(): Frame,
    getRect(out?: Rectangle): Rectangle,
    setTrim(
      trimmed: boolean,
      actualWidth: number,
      actualHeight: number,
      destX: number,
      destY: number,
      destWidth: number,
      destHeight: number,
    ): void,
    resize(width: number, height: number): void,
  }

  declare class FrameData {
    total: number,
    addFrame(frame: Frame): Frame,
    checkFrameName(name: string): boolean,
    clone(): FrameData,
    getFrame(index: number): Frame,
    getFrameByName(name: string): Frame,
    getFrameIndexes(
      frames?: number[],
      useNumericIndex?: boolean,
      output?: number[],
    ): number[],
    getFrameRange(start: number, end: number, output: Frame[]): Frame[],
    getFrames(
      frames?: number[],
      useNumericIndex?: boolean,
      output?: Frame[],
    ): Frame[],
  }

  declare interface IGameConfig {
    enableDebug?: boolean,
    width?: number,
    height?: number,
    renderer?: number,
    parent?: any,
    transparent?: boolean,
    antialias?: boolean,
    resolution?: number,
    preserveDrawingBuffer?: boolean,
    physicsConfig?: any,
    seed?: string,
    state?: State,
    forceSetTimeOut?: boolean,
    multiTextue?: boolean,
  }

  declare class GameObjectCreator {
    constructor(game: Game): this,
    game: Game,
    world: World,
    audio(
      key: string,
      volume?: number,
      loop?: boolean,
      connect?: boolean,
    ): Sound,
    audioSprite(key: string): AudioSprite,
    bitmapData(
      width?: number,
      height?: number,
      key?: string,
      addToCache?: boolean,
    ): BitmapData,
    bitmapText(
      x: number,
      y: number,
      font: string,
      text?: string,
      size?: number,
      align?: string,
    ): BitmapText,
    button(
      x?: number,
      y?: number,
      key?: string,
      callback?: Function,
      callbackContext?: any,
      overFrame?: any,
      outFrame?: any,
      downFrame?: any,
      upFrame?: any,
    ): Button,
    emitter(
      x?: number,
      y?: number,
      maxParticles?: number,
    ): Particles$Arcade$Emitter,
    filter(filter: any, ...args: any[]): Filter,
    graphics(x?: number, y?: number): Graphics,
    group(
      parent?: any,
      name?: string,
      addToStage?: boolean,
      enableBody?: boolean,
      physicsBodyType?: number,
    ): Group,
    image(x: number, y: number, key?: any, frame?: any): Image,
    renderTexture(
      width?: number,
      height?: number,
      key?: any,
      addToCache?: boolean,
    ): RenderTexture,
    retroFont(
      font: string,
      characterWidth: number,
      characterHeight: number,
      chars: string,
      charsPerRow: number,
      xSpacing?: number,
      ySpacing?: number,
      xOffset?: number,
      yOffset?: number,
    ): RetroFont,
    rope(x: number, y: number, key: any, frame?: any, points?: Point[]): Rope,
    sound(
      key: string,
      volume?: number,
      loop?: boolean,
      connect?: boolean,
    ): Sound,
    sprite(x: number, y: number, key?: any, frame?: any): Sprite,
    spriteBatch(parent: any, name?: String, addToStage?: boolean): SpriteBatch,
    text(x: number, y: number, text?: string, style?: any): Text,
    tilemap(
      key: string,
      tileWidth?: number,
      tileHeight?: number,
      width?: number,
      height?: number,
    ): Tilemap,
    tileSprite(
      x: number,
      y: number,
      width: number,
      height: number,
      key: any,
      frame: any,
    ): TileSprite,
    tween(obj: any): Tween,
  }

  declare class GameObjectFactory {
    constructor(game: Game): this,
    game: Game,
    world: World,
    audio(
      key: string,
      volume?: number,
      loop?: boolean,
      connect?: boolean,
    ): Sound,
    audioSprite(key: string): AudioSprite,
    bitmapData(
      width?: number,
      height?: number,
      key?: string,
      addToCache?: boolean,
    ): BitmapData,
    bitmapText(
      x: number,
      y: number,
      font: string,
      text?: string,
      size?: number,
      group?: Group,
    ): BitmapText,
    button(
      x?: number,
      y?: number,
      key?: string,
      callback?: Function,
      callbackContext?: any,
      overFrame?: any,
      outFrame?: any,
      downFrame?: any,
      upFrame?: any,
      group?: Group,
    ): Button,
    emitter(
      x?: number,
      y?: number,
      maxParticles?: number,
    ): Particles$Arcade$Emitter,
    existing(object: any): any,
    filter(filter: string, ...args: any[]): Filter,
    graphics(x: number, y: number, group?: Group): Graphics,
    group(
      parent?: any,
      name?: string,
      addToStage?: boolean,
      enableBody?: boolean,
      physicsBodyType?: number,
    ): Group,
    image(x: number, y: number, key?: any, frame?: any, group?: Group): Image,
    physicsGroup(
      physicsBodyType?: number,
      parent?: any,
      name?: string,
      addToStage?: boolean,
    ): Group,
    plugin(plugin: Plugin, ...parameter: any[]): Plugin,
    renderTexture(
      width?: number,
      height?: number,
      key?: string,
      addToCache?: boolean,
    ): RenderTexture,
    retroFont(
      font: string,
      characterWidth: number,
      characterHeight: number,
      chars: string,
      charsPerRow: number,
      xSpacing?: number,
      ySpacing?: number,
      xOffset?: number,
      yOffset?: number,
    ): RetroFont,
    rope(x: number, y: number, key: any, frame?: any, points?: Point[]): Rope,
    sound(
      key: string,
      volume?: number,
      loop?: boolean,
      connect?: boolean,
    ): Sound,
    sprite(x: number, y: number, key?: any, frame?: any, group?: Group): Sprite,
    spriteBatch(parent: any, name?: string, addToStage?: boolean): Group,
    text(x: number, y: number, text: string, style: any, group?: Group): Text,
    tilemap(
      key?: string,
      tileWidth?: number,
      tileHeight?: number,
      width?: number,
      height?: number,
    ): Tilemap,
    tileSprite(
      x: number,
      y: number,
      width: number,
      height: number,
      key?: any,
      frame?: any,
      group?: Group,
    ): TileSprite,
    tween(obj: any): Tween,
    weapon(quantity?: number, key?: any, frame?: any, group?: Group): Weapon,
    video(key?: string, url?: string): Video,
  }

  declare class Gamepad {
    constructor(game: Game): this,
    BUTTON_0: number,
    BUTTON_1: number,
    BUTTON_2: number,
    BUTTON_3: number,
    BUTTON_4: number,
    BUTTON_5: number,
    BUTTON_6: number,
    BUTTON_7: number,
    BUTTON_8: number,
    BUTTON_9: number,
    BUTTON_10: number,
    BUTTON_11: number,
    BUTTON_12: number,
    BUTTON_13: number,
    BUTTON_14: number,
    BUTTON_15: number,
    AXIS_0: number,
    AXIS_1: number,
    AXIS_2: number,
    AXIS_3: number,
    AXIS_4: number,
    AXIS_5: number,
    AXIS_6: number,
    AXIS_7: number,
    AXIS_8: number,
    AXIS_9: number,
    XBOX360_A: number,
    XBOX360_B: number,
    XBOX360_X: number,
    XBOX360_Y: number,
    XBOX360_LEFT_BUMPER: number,
    XBOX360_RIGHT_BUMPER: number,
    XBOX360_LEFT_TRIGGER: number,
    XBOX360_RIGHT_TRIGGER: number,
    XBOX360_BACK: number,
    XBOX360_START: number,
    XBOX360_STICK_LEFT_BUTTON: number,
    XBOX360_STICK_RIGHT_BUTTON: number,
    XBOX360_DPAD_LEFT: number,
    XBOX360_DPAD_RIGHT: number,
    XBOX360_DPAD_UP: number,
    XBOX360_DPAD_DOWN: number,
    XBOX360_STICK_LEFT_X: number,
    XBOX360_STICK_LEFT_Y: number,
    XBOX360_STICK_RIGHT_X: number,
    XBOX360_STICK_RIGHT_Y: number,
    PS3XC_X: number,
    PS3XC_CIRCLE: number,
    PS3XC_SQUARE: number,
    PS3XC_TRIANGLE: number,
    PS3XC_L1: number,
    PS3XC_R1: number,
    PS3XC_L2: number,
    PS3XC_R2: number,
    PS3XC_SELECT: number,
    PS3XC_START: number,
    PS3XC_STICK_LEFT_BUTTON: number,
    PS3XC_STICK_RIGHT_BUTTON: number,
    PS3XC_DPAD_UP: number,
    PS3XC_DPAD_DOWN: number,
    PS3XC_DPAD_LEFT: number,
    PS3XC_DPAD_RIGHT: number,
    PS3XC_STICK_LEFT_X: number,
    PS3XC_STICK_LEFT_Y: number,
    PS3XC_STICK_RIGHT_X: number,
    PS3XC_STICK_RIGHT_Y: number,
    active: boolean,
    callbackContext: any,
    enabled: boolean,
    game: Game,
    onAxisCallBack: Function,
    onConnectCallback: Function,
    onDisconnectCallback: Function,
    onDownCallback: Function,
    onFloatCallback: Function,
    onUpCallback: Function,
    pad1: SinglePad,
    pad2: SinglePad,
    pad3: SinglePad,
    pad4: SinglePad,
    padsConnected: number,
    supported: boolean,
    addCallbacks(context: any, callbacks: any): void,
    isDown(buttonCode: number): boolean,
    justPressed(buttonCode: number, duration?: number): boolean,
    justReleased(buttonCode: number, duration?: number): boolean,
    reset(): void,
    setDeadZones(value: any): void,
    start(): void,
    stop(): void,
    update(): void,
  }

  declare class Graphics extends PIXI.Graphics {
    constructor(game: Game, x?: number, y?: number): this,
    angle: number,
    alive: boolean,
    animations: AnimationManager,
    autoCull: boolean,
    body: Physics$Arcade$Body | Physics$P2$Body | Physics$Ninja$Body | any,
    bottom: number,
    cameraOffset: Point,
    checkWorldBounds: boolean,
    components: any,
    data: any,
    debug: boolean,
    destroyPhase: boolean,
    exists: boolean,
    events: Events,
    fixedToCamera: boolean,
    key: string | RenderTexture | BitmapData | Video | PIXI.Texture,
    fresh: boolean,
    game: Game,
    height: number,
    input: InputHandler,
    inputEnabled: boolean,
    inCamera: boolean,
    inWorld: boolean,
    left: number,
    name: string,
    lifespan: number,
    offsetX: number,
    offsetY: number,
    outOfBoundsKill: boolean,
    pendingDestroy: boolean,
    physicsType: number,
    position: Point,
    previousPosition: Point,
    previousRotation: number,
    renderOrderID: number,
    right: number,
    top: number,
    type: number,
    world: Point,
    width: number,
    z: number,
    alignIn(
      container:
        | Rectangle
        | Sprite
        | Image
        | Text
        | BitmapText
        | Button
        | Graphics
        | TileSprite,
      position?: number,
      offsetX?: number,
      offsetY?: number,
    ): any,
    alignTo(
      container:
        | Rectangle
        | Sprite
        | Image
        | Text
        | BitmapText
        | Button
        | Graphics
        | TileSprite,
      position?: number,
      offsetX?: number,
      offsetY?: number,
    ): any,
    destroy(destroyChildren?: boolean): void,
    drawTriangle(points: Point[], cull?: boolean): void,
    drawTriangles(
      vertices: Point[] | number[],
      indices?: number[],
      cull?: boolean,
    ): void,
    kill(): Graphics,
    postUpdate(): void,
    preUpdate(): void,
    reset(x: number, y: number, health?: number): Graphics,
    revive(health?: number): Graphics,
    update(): void,
  }

  declare class Group extends PIXI.DisplayObjectContainer {
    constructor(
      game: Game,
      parent?: PIXI.DisplayObjectContainer,
      name?: string,
      addToStage?: boolean,
      enableBody?: boolean,
      physicsBodyType?: number,
    ): this,
    RETURN_CHILD: number,
    RETURN_NONE: number,
    RETURN_TOTAL: number,
    RETURN_ALL: number,
    SORT_ASCENDING: number,
    SORT_DESCENDING: number,
    alpha: number,
    angle: number,
    alive: boolean,
    bottom: number,
    cameraOffset: Point,
    centerX: number,
    centerY: number,
    classType: any,
    cursor: any,
    cursorIndex: number,
    enableBody: boolean,
    enableBodyDebug: boolean,
    exists: boolean,
    fixedToCamera: boolean,
    game: Game,
    hash: PIXI.DisplayObject[],
    ignoreDestroy: boolean,
    inputEnableChildren: boolean,
    left: number,
    length: number,
    name: string,
    onChildInputDown: Signal,
    onChildInputUp: Signal,
    onChildInputOver: Signal,
    onChildInputOut: Signal,
    onDestroy: Signal,
    pendingDestroy: boolean,
    physicsBodyType: number,
    physicsType: number,
    physicsSortDirection: number,
    position: Point,
    right: number,
    rotation: number,
    scale: Point,
    top: number,
    total: number,
    type: number,
    visible: boolean,
    z: number,
    add(child: any, silent?: boolean, index?: number): any,
    addAll(
      property: string,
      amount: number,
      checkAlive: boolean,
      checkVisible: boolean,
    ): void,
    addAt(child: any, index: number, silent?: boolean): any,
    addMultiple(children: any[], silent?: boolean): any[],
    addToHash(child: PIXI.DisplayObject): boolean,
    align(
      width: number,
      height: number,
      cellWidth: number,
      cellHeight: number,
      position?: number,
      offset?: number,
    ): boolean,
    alignIn(
      container:
        | Rectangle
        | Sprite
        | Image
        | Text
        | BitmapText
        | Button
        | Graphics
        | TileSprite,
      position?: number,
      offsetX?: number,
      offsetY?: number,
    ): Group,
    alignTo(
      container:
        | Rectangle
        | Sprite
        | Image
        | Text
        | BitmapText
        | Button
        | Graphics
        | TileSprite,
      position?: number,
      offsetX?: number,
      offsetY?: number,
    ): Group,
    bringToTop(child: any): any,
    callAll(method: string, context: any, ...parameters: any[]): void,
    callAllExists(
      callback: string,
      existsValue: boolean,
      ...parameters: any[]
    ): void,
    callbackFromArray(child: any, callback: Function, length: number): void,
    checkAll(
      key: string[],
      value: any,
      checkAlive?: boolean,
      checkVisible?: boolean,
      force?: boolean,
    ): boolean,
    checkProperty(
      child: any,
      key: string[],
      value: any,
      force?: boolean,
    ): boolean,
    countDead(): number,
    countLiving(): number,
    create(
      x: number,
      y: number,
      key?: string | RenderTexture | BitmapData | Video | PIXI.Texture,
      frame?: string | number,
      exists?: boolean,
      index?: number,
    ): any,
    createMultiple(
      quantity: number,
      key: string | string[],
      frame?: any | any[],
      exists?: boolean,
    ): any[],
    customSort(sortHandler: Function, context?: any): void,
    destroy(destroyChildren?: boolean, soft?: boolean): void,
    divideAll(
      property: string,
      amount: number,
      checkAlive?: boolean,
      checkVisible?: boolean,
    ): void,
    forEach(
      callback: Function,
      callbackContext: any,
      checkExists?: boolean,
      ...args: any[]
    ): void,
    forEachAlive(
      callback: Function,
      callbackContext?: any,
      ...args: any[]
    ): void,
    forEachDead(
      callback: Function,
      callbackContext?: any,
      ...args: any[]
    ): void,
    forEachExists(callback: Function, callbackContext?: any): void,
    filter(predicate: Function, checkExists?: boolean): ArraySet,
    getAt(index: number): PIXI.DisplayObject | number,
    getBottom(): any,
    getByName(name: string): any,
    getClosestTo(object: any, callback?: Function, callbackContext?: any): any,
    getFirstAlive(
      createIfNull?: boolean,
      x?: number,
      y?: number,
      key?: string | RenderTexture | BitmapData | Video | PIXI.Texture,
      frame?: string | number,
    ): any,
    getFirstDead(
      createIfNull?: boolean,
      x?: number,
      y?: number,
      key?: string | RenderTexture | BitmapData | Video | PIXI.Texture,
      frame?: string | number,
    ): any,
    getFirstExists(
      exists: boolean,
      createIfNull?: boolean,
      x?: number,
      y?: number,
      key?: string | RenderTexture | BitmapData | Video | PIXI.Texture,
      frame?: string | number,
    ): any,
    getFurthestFrom(
      object: any,
      callback?: Function,
      callbackContext?: any,
    ): any,
    getIndex(child: any): number,
    getRandom(startIndex?: number, length?: number): any,
    getTop(): any,
    hasProperty(child: any, key: string[]): boolean,
    iterate(
      key: string,
      value: any,
      returnType: number,
      callback?: Function,
      callbackContext?: any,
      ...args: any[]
    ): any,
    moveAll(group: Group, silent?: boolean): Group,
    moveDown(child: any): any,
    moveUp(child: any): any,
    multiplyAll(
      property: string,
      amount: number,
      checkAlive: boolean,
      checkVisible: boolean,
    ): void,
    next(): any,
    postUpdate(): void,
    preUpdate(): void,
    previous(): void,
    remove(child: any, destroy?: boolean, silent?: boolean): boolean,
    removeAll(
      destroy?: boolean,
      silent?: boolean,
      destroyTexture?: boolean,
    ): void,
    removeBetween(
      startIndex: number,
      endIndex?: number,
      destroy?: boolean,
      silent?: boolean,
    ): void,
    removeFromHash(child: PIXI.DisplayObject): boolean,
    replace(oldChild: any, newChild: any): any,
    resetChild(
      child: any,
      x?: number,
      y?: number,
      key?: string | RenderTexture | BitmapData | Video | PIXI.Texture,
      frame?: string | number,
    ): any,
    resetCursor(index?: number): any,
    reverse(): void,
    sendToBack(child: any): any,
    set(
      child: any,
      key: string[],
      value: any,
      operation?: number,
      force?: boolean,
    ): boolean,
    setAll(
      key: string,
      value: any,
      checkAlive?: boolean,
      checkVisible?: boolean,
      operation?: number,
      force?: boolean,
    ): void,
    setAllChildren(
      key: string,
      value: any,
      checkAlive?: boolean,
      checkVisible?: boolean,
      operation?: number,
      force?: boolean,
    ): void,
    setProperty(
      child: any,
      key: string[],
      value: any,
      operation?: number,
      force?: boolean,
    ): boolean,
    sort(key?: string, order?: number): void,
    subAll(
      property: string,
      amount: number,
      checkAlive: boolean,
      checkVisible: boolean,
    ): void,
    swap(child1: any, child2: any): boolean,
    update(): void,
    updateZ(): void,
    xy(index: number, x: number, y: number): void,
  }

  declare class Image extends PIXI.Sprite {
    constructor(
      game: Game,
      x: number,
      y: number,
      key: string | RenderTexture | BitmapData | PIXI.Texture,
      frame?: string | number,
    ): this,
    alive: boolean,
    angle: number,
    anchor: Point,
    animations: AnimationManager,
    autoCull: boolean,
    bottom: number,
    cameraOffset: Point,
    centerX: number,
    centerY: number,
    components: any,
    cropRect: Rectangle,
    customRender: boolean,
    data: any,
    debug: boolean,
    deltaX: number,
    deltaY: number,
    deltaZ: number,
    destroyPhase: boolean,
    events: Events,
    exists: boolean,
    fixedToCamera: boolean,
    frame: string | number,
    frameName: string,
    fresh: boolean,
    game: Game,
    inCamera: boolean,
    input: InputHandler,
    inputEnabled: boolean,
    inWorld: boolean,
    key: string | RenderTexture | BitmapData | Video | PIXI.Texture,
    lifespan: number,
    left: number,
    name: string,
    offsetX: number,
    offsetY: number,
    pendingDestroy: boolean,
    position: Point,
    previousPosition: Point,
    previousRotation: number,
    renderOrderID: number,
    right: number,
    scale: Point,
    smoothed: boolean,
    top: number,
    type: number,
    world: Point,
    z: number,
    alignIn(
      container:
        | Rectangle
        | Sprite
        | Image
        | Text
        | BitmapText
        | Button
        | Graphics
        | TileSprite,
      position?: number,
      offsetX?: number,
      offsetY?: number,
    ): any,
    alignTo(
      container:
        | Rectangle
        | Sprite
        | Image
        | Text
        | BitmapText
        | Button
        | Graphics
        | TileSprite,
      position?: number,
      offsetX?: number,
      offsetY?: number,
    ): any,
    bringToTop(): Image,
    crop(rect: Rectangle, copy?: boolean): void,
    destroy(destroyChildren?: boolean): void,
    kill(): Image,
    loadTexture(
      key: string | RenderTexture | BitmapData | Video | PIXI.Texture,
      frame?: string | number,
      stopAnimation?: boolean,
    ): void,
    resizeFrame(parent: any, width: number, height: number): void,
    moveDown(): Image,
    moveUp(): Image,
    overlap(
      displayObject: Sprite | Image | TileSprite | Button | PIXI.DisplayObject,
    ): boolean,
    play(
      name: string,
      frameRate?: number,
      loop?: boolean,
      killOnComplete?: boolean,
    ): Animation,
    postUpdate(): void,
    preUpdate(): void,
    reset(x: number, y: number, health?: number): Image,
    resetFrame(): void,
    revive(health?: number): Image,
    sendToBack(): Image,
    setFrame(frame: Frame): void,
    update(): void,
    updateCrop(): void,
  }

  declare class ImageCollection {
    constructor(
      name: string,
      firstgid: number,
      width?: number,
      height?: number,
      margin?: number,
      spacing?: number,
      properties?: any,
    ): this,
    name: string,
    firstgid: number,
    imageWidth: number,
    imageHeight: number,
    imageMargin: number,
    imageSpacing: number,
    properties: any,
    images: any[],
    total: number,
    addImage(gid: number, image: string): void,
    containsImageIndex(imageIndex: number): boolean,
  }

  declare class Input {
    constructor(game: Game): this,
    MAX_POINTERS: number,
    MOUSE_OVERRIDES_TOUCH: number,
    MOUSE_TOUCH_COMBINE: number,
    TOUCH_OVERRIDES_MOUSE: number,
    activePointer: Pointer,
    circle: Circle,
    enabled: boolean,
    doubleTapRate: number,
    game: Game,
    gamepad: Gamepad,
    hitCanvas: HTMLCanvasElement,
    hitContext: CanvasRenderingContext2D,
    holdRate: number,
    interactiveItems: ArraySet,
    justPressedRate: number,
    justReleasedRate: number,
    keyboard: Keyboard,
    maxPointers: number,
    minPriorityID: number,
    mouse: Mouse,
    mousePointer: Pointer,
    moveCallbacks: (pointer: Pointer, x: number, y: number) => void[],
    mspointer: MSPointer,
    multiInputOverride: number,
    onDown: Signal,
    onHold: Signal,
    onTap: Signal,
    onUp: Signal,
    pointer1: Pointer,
    pointer2: Pointer,
    pointer3: Pointer,
    pointer4: Pointer,
    pointer5: Pointer,
    pointer6: Pointer,
    pointer7: Pointer,
    pointer8: Pointer,
    pointer9: Pointer,
    pointer10: Pointer,
    pollLocked: boolean,
    pollRate: number,
    position: Point,
    pointer: Pointer[],
    recordLimit: number,
    recordPointerHistory: boolean,
    recordRate: number,
    resetLocked: boolean,
    scale: Point,
    speed: Point,
    tapRate: number,
    totalActivePointers: number,
    totalInactivePointers: number,
    touch: Touch,
    worldX: number,
    worldY: number,
    x: number,
    y: number,
    addPointer(): Pointer,
    addMoveCallback(callback: Function, context: any): number,
    boot(): void,
    countActivePointers(limit?: number): number,
    deleteMoveCallback(callback: Function, context?: any): void,
    destroy(): void,
    getLocalPosition(displayObject: any, pointer: Pointer): Point,
    getPointer(isActive?: boolean): Pointer,
    getPointerFromId(pointerID: number): Pointer,
    getPointerFromIdentifier(identifier: number): Pointer,
    hitTest(
      displayObject: PIXI.DisplayObject,
      pointer: Pointer,
      localPoint: Point,
    ): void,
    reset(hard?: boolean): void,
    resetSpeed(x: number, y: number): void,
    setInteractiveCandidateHandler(callback: Function, context?: any): void,
    startPointer(event: any): Pointer,
    stopPointer(event: any): Pointer,
    update(): void,
    updatePointer(event: any): Pointer,
  }

  declare class InputHandler {
    constructor(sprite: Sprite): this,
    allowHorizontalDrag: boolean,
    allowVerticalDrag: boolean,
    boundsRect: Rectangle,
    boundsSprite: Sprite,
    bringToTop: boolean,
    downPoint: Point,
    dragDistanceThreshold: number,
    dragOffset: Point,
    dragFromCenter: boolean,
    draggable: boolean,
    dragStartPoint: Point,
    dragStopBlocksInputUp: boolean,
    dragTimeThreshold: number,
    enabled: boolean,
    game: Game,
    globalToLocalX(x: number): number,
    globalToLocalY(y: number): number,
    isDragged: boolean,
    pixelPerfectAlpha: number,
    pixelPerfectClick: boolean,
    pixelPerfectOver: boolean,
    priorityID: number,
    scaleLayer: boolean,
    snapOffset: Point,
    snapOffsetX: number,
    snapOffsetY: number,
    snapOnDrag: boolean,
    snapOnRelease: boolean,
    snapPoint: Point,
    snapX: number,
    snapY: number,
    sprite: Sprite,
    useHandCursor: boolean,
    checkBoundsRect(): void,
    checkBoundsSprite(): void,
    checkPixel(x: number, y: number, pointer?: Pointer): boolean,
    checkPointerDown(pointer: Pointer, fastTest?: boolean): boolean,
    checkPointerOver(pointer: Pointer, fastTest?: boolean): boolean,
    destroy(): void,
    disableDrag(): void,
    disableSnap(): void,
    downDuration(pointerId?: number): number,
    enableDrag(
      lockCenter?: boolean,
      bringToTop?: boolean,
      pixelPerfect?: boolean,
      alphaThreshold?: number,
      boundsRect?: Rectangle,
      boundsSprite?: Sprite,
    ): void,
    enableSnap(
      snapX: number,
      snapY: number,
      onDrag?: boolean,
      onRelease?: boolean,
      snapOffsetX?: number,
      snapOffsetY?: number,
    ): void,
    isPixelPerfect(): boolean,
    justOut(pointerId?: number, delay?: number): boolean,
    justOver(pointerId?: number, delay?: number): boolean,
    justPressed(pointerId?: number, delay?: number): boolean,
    justReleased(pointerId?: number, delay?: number): boolean,
    overDuration(pointerId?: number): number,
    pointerDown(pointerId?: number): boolean,
    pointerDragged(pointerId?: number): boolean,
    pointerOut(pointerId?: number): boolean,
    pointerOver(pointerId?: number): boolean,
    pointerTimeDown(pointerId?: number): number,
    pointerTimeOut(pointerId?: number): number,
    pointerTimeOver(pointerId?: number): number,
    pointerTimeUp(pointerId?: number): number,
    pointerUp(pointerId?: number): boolean,
    pointerX(pointerId?: number): number,
    pointerY(pointerId?: number): number,
    reset(): void,
    setDragLock(allowHorizontal?: boolean, allowVertical?: boolean): void,
    start(priority: number, useHandCursor: boolean): Sprite,
    startDrag(pointer: Pointer): void,
    stop(): void,
    stopDrag(pointer: Pointer): void,
    update(pointer: Pointer): void,
    updateDrag(pointer: Pointer): boolean,
    validForInput(
      highestID: number,
      highestRenderID: number,
      includePixelPerfect?: boolean,
    ): boolean,
  }

  declare class Key {
    constructor(game: Game, keycode: number): this,
    altKey: boolean,
    ctrlKey: boolean,
    duration: number,
    enabled: boolean,
    event: any,
    game: Game,
    isDown: boolean,
    isUp: boolean,
    _justDown: boolean,
    justDown: boolean,
    _justUp: boolean,
    justUp: boolean,
    keyCode: number,
    onDown: Signal,
    onHoldCallback: Function,
    onHoldContext: any,
    onUp: Signal,
    repeats: number,
    shiftKey: boolean,
    timeDown: number,
    timeUp: number,
    downDuration(duration?: number): boolean,
    processKeyDown(event: KeyboardEvent): void,
    processKeyUp(event: KeyboardEvent): void,
    reset(hard?: boolean): void,
    update(): void,
    upDuration(duration?: number): boolean,
  }

  declare class Keyboard {
    constructor(game: Game): this,
    A: number,
    B: number,
    C: number,
    D: number,
    E: number,
    F: number,
    G: number,
    H: number,
    I: number,
    J: number,
    K: number,
    L: number,
    M: number,
    N: number,
    O: number,
    P: number,
    Q: number,
    R: number,
    S: number,
    T: number,
    U: number,
    V: number,
    W: number,
    X: number,
    Y: number,
    Z: number,
    ZERO: number,
    ONE: number,
    TWO: number,
    THREE: number,
    FOUR: number,
    FIVE: number,
    SIX: number,
    SEVEN: number,
    EIGHT: number,
    NINE: number,
    NUMPAD_0: number,
    NUMPAD_1: number,
    NUMPAD_2: number,
    NUMPAD_3: number,
    NUMPAD_4: number,
    NUMPAD_5: number,
    NUMPAD_6: number,
    NUMPAD_7: number,
    NUMPAD_8: number,
    NUMPAD_9: number,
    NUMPAD_MULTIPLY: number,
    NUMPAD_ADD: number,
    NUMPAD_ENTER: number,
    NUMPAD_SUBTRACT: number,
    NUMPAD_DECIMAL: number,
    NUMPAD_DIVIDE: number,
    F1: number,
    F2: number,
    F3: number,
    F4: number,
    F5: number,
    F6: number,
    F7: number,
    F8: number,
    F9: number,
    F10: number,
    F11: number,
    F12: number,
    F13: number,
    F14: number,
    F15: number,
    COLON: number,
    EQUALS: number,
    COMMA: number,
    UNDERSCORE: number,
    PERIOD: number,
    QUESTION_MARK: number,
    TILDE: number,
    OPEN_BRACKET: number,
    BACKWARD_SLASH: number,
    CLOSED_BRACKET: number,
    QUOTES: number,
    BACKSPACE: number,
    TAB: number,
    CLEAR: number,
    ENTER: number,
    SHIFT: number,
    CONTROL: number,
    ALT: number,
    CAPS_LOCK: number,
    ESC: number,
    SPACEBAR: number,
    PAGE_UP: number,
    PAGE_DOWN: number,
    END: number,
    HOME: number,
    LEFT: number,
    UP: number,
    RIGHT: number,
    DOWN: number,
    INSERT: number,
    DELETE: number,
    HELP: number,
    NUM_LOCK: number,
    PLUS: number,
    MINUS: number,
    callbackContext: any,
    enabled: boolean,
    event: any,
    game: Game,
    lastChar: string,
    lastKey: Key,
    onDownCallback: Function,
    onPressCallback: Function,
    onUpCallback: Function,
    pressEvent: any,
    addCallbacks(
      context: any,
      onDown?: Function,
      onUp?: Function,
      onPress?: Function,
    ): void,
    addKey(keycode: number): Key,
    addKeys(keys: any): any,
    addKeyCapture(keycode: any): void,
    createCursorKeys(): CursorKeys,
    clearCaptures(): void,
    destroy(): void,
    downDuration(keycode: number, duration?: number): boolean,
    isDown(keycode: number): boolean,
    processKeyDown(event: KeyboardEvent): void,
    processKeyPress(event: KeyboardEvent): void,
    processKeyUp(event: KeyboardEvent): void,
    removeKey(keycode: number): void,
    removeKeyCapture(keycode: number): void,
    reset(hard?: boolean): void,
    start(): void,
    stop(): void,
    update(): void,
    upDuration(keycode: number, duration?: number): boolean,
  }

  declare class KeyCode {
    A: number,
    B: number,
    C: number,
    D: number,
    E: number,
    F: number,
    G: number,
    H: number,
    I: number,
    J: number,
    K: number,
    L: number,
    M: number,
    N: number,
    O: number,
    P: number,
    Q: number,
    R: number,
    S: number,
    T: number,
    U: number,
    V: number,
    W: number,
    X: number,
    Y: number,
    Z: number,
    ZERO: number,
    ONE: number,
    TWO: number,
    THREE: number,
    FOUR: number,
    FIVE: number,
    SIX: number,
    SEVEN: number,
    EIGHT: number,
    NINE: number,
    NUMPAD_0: number,
    NUMPAD_1: number,
    NUMPAD_2: number,
    NUMPAD_3: number,
    NUMPAD_4: number,
    NUMPAD_5: number,
    NUMPAD_6: number,
    NUMPAD_7: number,
    NUMPAD_8: number,
    NUMPAD_9: number,
    NUMPAD_MULTIPLY: number,
    NUMPAD_ADD: number,
    NUMPAD_ENTER: number,
    NUMPAD_SUBTRACT: number,
    NUMPAD_DECIMAL: number,
    NUMPAD_DIVIDE: number,
    F1: number,
    F2: number,
    F3: number,
    F4: number,
    F5: number,
    F6: number,
    F7: number,
    F8: number,
    F9: number,
    F10: number,
    F11: number,
    F12: number,
    F13: number,
    F14: number,
    F15: number,
    COLON: number,
    EQUALS: number,
    COMMA: number,
    UNDERSCORE: number,
    PERIOD: number,
    QUESTION_MARK: number,
    TILDE: number,
    OPEN_BRACKET: number,
    BACKWARD_SLASH: number,
    CLOSED_BRACKET: number,
    QUOTES: number,
    BACKSPACE: number,
    TAB: number,
    CLEAR: number,
    ENTER: number,
    SHIFT: number,
    CONTROL: number,
    ALT: number,
    CAPS_LOCK: number,
    ESC: number,
    SPACEBAR: number,
    PAGE_UP: number,
    PAGE_DOWN: number,
    END: number,
    HOME: number,
    LEFT: number,
    UP: number,
    RIGHT: number,
    DOWN: number,
    INSERT: number,
    DELETE: number,
    HELP: number,
    NUM_LOCK: number,
    PLUS: number,
    MINUS: number,
  }

  declare class Line {
    constructor(x1?: number, y1?: number, x2?: number, y2?: number): this,
    angle: number,
    end: Point,
    height: number,
    left: number,
    length: number,
    normalAngle: number,
    normalX: number,
    normalY: number,
    perpSlope: number,
    right: number,
    slope: number,
    start: Point,
    top: number,
    type: number,
    width: number,
    x: number,
    y: number,
    intersectsPoints(
      a: Point,
      b: Point,
      e: Point,
      f: Point,
      asSegment?: boolean,
      result?: Point,
    ): Point,
    intersects(a: Line, b: Line, asSegment?: boolean, result?: Point): Point,
    intersectsRectangle(line: Line, rect: Rectangle): boolean,
    reflect(a: Line, b: Line): number,
    centerOn(x: number, y: number): Line,
    clone(output: Line): Line,
    coordinatesOnLine(stepRate: number, results: any[]): any[],
    fromAngle(x: number, y: number, angle: number, length: number): Line,
    fromSprite(
      startSprite: Sprite,
      endSprite: Sprite,
      useCenter?: boolean,
    ): Line,
    intersects(line: Line, asSegment?: boolean, result?: Point): Point,
    midPoint(out?: Point): Point,
    pointOnLine(x: number, y: number): boolean,
    pointOnSegment(x: number, y: number): boolean,
    random(out?: Point): Point,
    reflect(line: Line): number,
    rotate(angle: number, asDegrees?: boolean): Line,
    rotateAround(
      x: number,
      y: number,
      angle: number,
      asDegrees?: boolean,
    ): Line,
    setTo(x1?: number, y1?: number, x2?: number, y2?: number): Line,
  }

  declare class LinkedList {
    first: any,
    last: any,
    next: any,
    prev: any,
    total: number,
    add(item: any): any,
    callAll(callback: Function): void,
    remove(item: any): void,
    reset(): void,
  }

  declare class Loader {
    constructor(game: Game): this,
    PHYSICS_LIME_CORONA_JSON: number,
    PHYSICS_PHASER_JSON: number,
    TEXTURE_ATLAS_JSON_ARRAY: number,
    TEXTURE_ATLAS_JSON_HASH: number,
    TEXTURE_ATLAS_XML_STARLING: number,
    TEXTURE_ATLAS_JSON_PYXEL: number,
    baseURL: string,
    cache: Cache,
    crossOrigin: boolean | string,
    enableParallel: boolean,
    game: Game,
    hasLoaded: boolean,
    headers: any,
    isLoading: boolean,
    maxParallelDownloads: number,
    onFileStart: Signal,
    onFileComplete: Signal,
    onFileError: Signal,
    onLoadComplete: Signal,
    onLoadStart: Signal,
    onPackComplete: Signal,
    path: string,
    preloadSprite: any,
    progress: number,
    progressFloat: number,
    resetLocked: boolean,
    useXDomainRequest: boolean,
    asyncComplete(file: any, errorMessage?: string): void,
    addSyncPoint(type: string, key: string): Loader,
    addToFileList(
      type: string,
      key: string,
      url?: string,
      properties?: any,
      overwrite?: boolean,
      extension?: string,
    ): Loader,
    atlas(
      key: string,
      textureURL?: string,
      atlasURL?: string,
      atlasData?: any,
      format?: number,
    ): Loader,
    atlasJSONArray(
      key: string,
      textureURL?: string,
      atlasURL?: string,
      atlasData?: any,
    ): Loader,
    atlasJSONHash(
      key: string,
      textureURL?: string,
      atlasURL?: string,
      atlasData?: any,
    ): Loader,
    atlasXML(
      key: string,
      textureURL?: string,
      atlasURL?: string,
      atlasData?: any,
    ): Loader,
    audio(
      key: string,
      urls: string | string[] | any,
      autoDecode?: boolean,
    ): Loader,
    audiosprite(
      key: string,
      urls: string[],
      jsonURL?: string,
      jsonData?: string | any,
      autoDecode?: boolean,
    ): Loader,
    binary(
      key: string,
      url?: string,
      callback?: Function,
      callbackContext?: any,
    ): Loader,
    bitmapFont(
      key: string,
      textureURL?: string,
      atlasURL?: string,
      atlasData?: any,
      xSpacing?: number,
      ySpacing?: number,
    ): Loader,
    checkKeyExists(type: string, key: string): boolean,
    csvLoadComplete(file: any, xhr: XMLHttpRequest): void,
    fileComplete(file: any, xhr: XMLHttpRequest): void,
    fileError(file: any, xhr: XMLHttpRequest, reason: string): void,
    finishedLoading(abnormal?: boolean): void,
    getAsset(type: string, key: string): any,
    getAssetIndex(type: string, key: string): number,
    getAudioURL(urls: any[]): void,
    image(key: string, url?: string | any, overwrite?: boolean): Loader,
    images(keys: string[], urls?: string[]): Loader,
    json(key: string, url?: string, overwrite?: boolean): Loader,
    jsonLoadComplete(file: any, xhr: XMLHttpRequest): void,
    loadAudioTag(file: any): void,
    loadFile(file: any): void,
    loadImageTag(file: any): void,
    pack(key: string, url?: string, data?: any, callbackContext?: any): Loader,
    parseXml(data: string): XMLDocument,
    physics(key: string, url?: string, data?: any, format?: string): Loader,
    processLoadQueue(): void,
    processPack(pack: any): void,
    removeAll(): void,
    removeFile(type: string, key: string): void,
    replaceInFileList(
      type: string,
      key: string,
      url: string,
      properties: any,
    ): void,
    reset(hard?: boolean, clearEvents?: boolean): void,
    resize(): void,
    script(
      key: string,
      url?: String,
      callback?: Function,
      callbackContext?: any,
    ): Loader,
    shader(key: string, url?: String, overwrite?: boolean): Loader,
    setPreloadSprite(sprite: Sprite | Image, direction?: number): void,
    spritesheet(
      key: string,
      url: string,
      frameWidth: number,
      frameHeight: number,
      frameMax?: number,
      margin?: number,
      spacing?: number,
      skipFrames?: number,
    ): Loader,
    start(): void,
    text(key: string, url?: string, overwrite?: boolean): Loader,
    texture(key: string, object: any, overwrite?: boolean): Loader,
    tilemap(key: string, url?: string, data?: any, format?: number): Loader,
    totalLoadedFiles(): number,
    totalLoadedPacks(): number,
    totalQueuedFiles(): number,
    totalQueuedPacks(): number,
    transformUrl(url: string, file?: any): string,
    updateProgress(): void,
    video(
      key: string,
      urls: string | string[] | any,
      loadEvent?: string,
      asBlob?: boolean,
    ): Loader,
    withSyncPoint(callback: Function, callbackContext?: any): Loader,
    xml(key: string, url?: string, overwrite?: boolean): Loader,
    xhrLoad(
      file: any,
      url: string,
      type: string,
      onload: Function,
      onerror?: Function,
    ): void,
    xhrLoadWithXDR(
      file: any,
      url: string,
      type: string,
      onload: Function,
      onerror?: Function,
    ): void,
    xmlLoadComplete(file: any, xhr: XMLHttpRequest): void,
  }

  declare class LoaderParser {
    bitmapFont(
      xml: any,
      baseTexture: PIXI.BaseTexture,
      xSpacing?: number,
      ySpacing?: number,
    ): any,
    xmlBitmapFont(
      xml: any,
      baseTexture: PIXI.BaseTexture,
      xSpacing?: number,
      ySpacing?: number,
      frame?: Frame,
    ): any,
    jsonBitmapFont(
      json: any,
      baseTexture: PIXI.BaseTexture,
      xSpacing?: number,
      ySpacing?: number,
      frame?: Frame,
    ): any,
  }

  declare class Matrix extends PIXI.Matrix {
    a: number,
    b: number,
    c: number,
    d: number,
    tx: number,
    ty: number,
    type: number,
    constructor(
      a?: number,
      b?: number,
      c?: number,
      d?: number,
      tx?: number,
      ty?: number,
    ): this,
    apply(pos: Point, newPos?: Point): Point,
    applyInverse(pos: Point, newPos?: Point): Point,
    clone(output?: Matrix): Matrix,
    copyFrom(matrix: Matrix): Matrix,
    copyTo(matrix: Matrix): Matrix,
    fromArray(array: number[]): Matrix,
    setTo(
      a: number,
      b: number,
      c: number,
      d: number,
      tx: number,
      ty: number,
    ): Matrix,
    toArray(transpose?: boolean, array?: number[]): number[],
    translate(x: number, y: number): Matrix,
    scale(x: number, y: number): Matrix,
    rotate(angle: number): Matrix,
    append(matrix: Matrix): Matrix,
    identity(): Matrix,
  }

  declare class Math {
    angleBetween(x1: number, y1: number, x2: number, y2: number): number,
    angleBetweenPoints(point1: Point, point2: Point): number,
    angleBetweenY(x1: number, y1: number, x2: number, y2: number): number,
    angleBetweenPointsY(point1: Point, point2: Point): number,
    average(...numbers: number[]): number,
    bernstein(n: number, i: number): number,
    random(min: number, max: number): number,
    between(min: number, max: number): number,
    bezierInterpolation(v: number[], k: number): number,
    catmullRom(
      p0: number,
      p1: number,
      p2: number,
      p3: number,
      t: number,
    ): number,
    catmullRomInterpolation(v: number[], k: number): number,
    ceilTo(value: number, place?: number, base?: number): number,
    clamp(x: number, a: number, b: number): number,
    clampBottom(x: number, a: number): number,
    degToRad(degrees: number): number,
    difference(a: number, b: number): number,
    distance(x1: number, y1: number, x2: number, y2: number): number,
    distanceSq(x1: number, y1: number, x2: number, y2: number): number,
    distancePow(
      xy: number,
      y1: number,
      x2: number,
      y2: number,
      pow?: number,
    ): number,
    factorial(value: number): number,
    floorTo(value: number, place: number, base: number): number,
    fuzzyCeil(val: number, epsilon?: number): boolean,
    fuzzyEqual(a: number, b: number, epsilon?: number): boolean,
    fuzzyLessThan(a: Number, b: number, epsilon?: number): boolean,
    fuzzyFloor(val: number, epsilon?: number): boolean,
    fuzzyGreaterThan(a: number, b: number, epsilon?: number): boolean,
    fuzzyLessThan(a: number, b: number, epsilon?: number): boolean,
    getShortestAngle(angle1: number, angle2: number): number,
    getNextPowerOfTwo(value: number): number,
    isEven(n: number): boolean,
    isOdd(n: number): boolean,
    isPowerOfTwo(width: number, height: number): boolean,
    linear(p0: number, p1: number, t: number): number,
    linearInterpolation(v: number[], k: number): number,
    mapLinear(
      x: number,
      a1: number,
      a2: number,
      b1: number,
      b2: number,
    ): number,
    max(...numbers: number[]): number,
    maxAdd(value: number, amount: number, max: number): number,
    maxProperty(...numbers: number[]): number,
    min(...numbers: number[]): number,
    minProperty(...numbers: number[]): number,
    minSub(value: number, amount: number, min: number): number,
    normalizeAngle(angle: number, radians?: boolean): number,
    percent(a: number, b: number, base?: number): number,
    p2px(v: number): number,
    PI2: number,
    radToDeg(radians: number): number,
    reverseAngle(angleRed: number): number,
    rotateToAngle(
      currentAngle: number,
      targetAngle: number,
      lerp?: number,
    ): number,
    roundAwayFromZero(value: number): number,
    roundTo(value: number, place?: number, base?: number): number,
    shear(n: number): number,
    sign(x: number): number,
    sinCosGenerator(
      length: number,
      sinAmplitude?: number,
      cosAmplitude?: number,
      frequency?: number,
    ): {
      sin: number[],
      cos: number[],
    },
    smootherstep(x: number, min: number, max: number): number,
    smoothstep(x: number, min: number, max: number): number,
    snapTo(input: number, gap: number, start?: number): number,
    snapToCeil(input: number, gap: number, start?: number): number,
    snapToFloor(input: number, gap: number, start?: number): number,
    within(a: number, b: number, tolerance: number): boolean,
    wrap(value: number, min: number, max: number): number,
    wrapAngle(angle: number, radians?: boolean): number,
    wrapValue(value: number, amount: number, max: number): number,
  }

  declare interface WheelEventProxy {
    bindEvent(event: any): WheelEventProxy,
    type: string,
    deltaMode: number,
    deltaX: number,
    deltaY: number,
    deltaZ: number,
  }

  declare class Mouse {
    constructor(game: Game): this,
    NO_BUTTON: number,
    LEFT_BUTTON: number,
    MIDDLE_BUTTON: number,
    RIGHT_BUTTON: number,
    BACK_BUTTON: number,
    FORWARD_BUTTON: number,
    WHEEL_DOWN: number,
    WHEEL_UP: number,
    button: number,
    callbackContext: any,
    capture: boolean,
    enabled: boolean,
    event: MouseEvent,
    game: Game,
    input: Input,
    locked: boolean,
    mouseDownCallback: (event: MouseEvent) => void,
    mouseOutCallback: (event: MouseEvent) => void,
    mouseOverCallback: (event: MouseEvent) => void,
    mouseUpCallback: (event: MouseEvent) => void,
    mouseWheelCallback: (event: MouseEvent) => void,
    _onMouseDown: (event: MouseEvent) => void,
    _onMouseMove: (event: MouseEvent) => void,
    _onMouseUp: (event: MouseEvent) => void,
    _onMouseOut: (event: MouseEvent) => void,
    _onMouseOver: (event: MouseEvent) => void,
    _onMouseWheel: (event: MouseEvent) => void,
    _wheelEvent: WheelEventProxy,
    pointerLock: Signal,
    stopOnGameOut: boolean,
    wheelDelta: number,
    onMouseDown(event: MouseEvent): void,
    onMouseMove(event: MouseEvent): void,
    onMouseOut(event: MouseEvent): void,
    onMouseOver(event: MouseEvent): void,
    onMouseUp(event: MouseEvent): void,
    onMouseUpGlobal(event: MouseEvent): void,
    onMouseWheel(event: MouseEvent): void,
    pointerLockChange(event: MouseEvent): void,
    releasePointerLock(): void,
    requestPointerLock(): void,
    start(): void,
    stop(): void,
  }

  declare class MSPointer {
    constructor(game: Game): this,
    button: number,
    capture: boolean,
    callbackContext: any,
    event: MSPointerEvent,
    game: Game,
    input: Input,
    onPointerDown: (event: MSPointerEvent) => void,
    onPointerMove: (event: MSPointerEvent) => void,
    onPointerUp: (event: MSPointerEvent) => void,
    mouseDownCallback: (event: MSPointerEvent) => void,
    mouseMoveCallback: (event: MSPointerEvent) => void,
    mouseUpCallback: (event: MSPointerEvent) => void,
    pointerDownCallback: (event: MSPointerEvent) => void,
    pointerMoveCallback: (event: MSPointerEvent) => void,
    pointerUpCallback: (event: MSPointerEvent) => void,
    start(): void,
    stop(): void,
  }

  declare class Net {
    constructor(game: Game): this,
    game: Game,
    checkDomainName(domain: string): boolean,
    decodeURI(value: string): string,
    getHostName(): string,
    getQueryString(parameter?: string): string,
    updateQueryString(
      key: string,
      value: any,
      redirect?: boolean,
      url?: string,
    ): string,
  }

  declare class Particle extends Sprite {
    constructor(game: Game, x: number, y: number, key?: any, frame?: any): this,
    fresh: boolean,
    onEmit(): void,
    reset(x: number, y: number, health?: number): Particle,
    setAlphaData(data: any[]): void,
    setScaleData(data: any[]): void,
    update(): void,
  }

  declare class Particles {
    constructor(game: Game): this,
    emitters: any,
    game: Game,
    ID: number,
    add(emitter: Particles$Arcade$Emitter): Particles$Arcade$Emitter,
    remove(emitter: Particles$Arcade$Emitter): void,
    update(): void,
  }

  declare class Particles$Arcade$Emitter extends Group {
    constructor(
      game: Game,
      x?: number,
      y?: number,
      maxParticles?: number,
    ): this,
    alphaData: any[],
    autoAlpha: boolean,
    autoScale: boolean,
    angle: number,
    angularDrag: number,
    bottom: number,
    bounce: Point,
    emitX: number,
    emitY: number,
    exists: boolean,
    frequency: number,
    gravity: number,
    group: Group,
    height: number,
    left: number,
    lifespan: number,
    maxParticles: number,
    maxParticleScale: number,
    maxParticleSpeed: Point,
    maxRotation: number,
    minParticleScale: number,
    minParticleSpeed: Point,
    minRotation: number,
    name: string,
    on: boolean,
    particleAnchor: Point,
    particleBringToTop: boolean,
    particleSendToBack: boolean,
    particleClass: any,
    particleDrag: Point,
    physicsType: number,
    position: Point,
    right: number,
    scaleData: any[],
    top: number,
    type: number,
    width: number,
    x: number,
    y: number,
    at(object: any): Particles$Arcade$Emitter,
    emitParticle(
      x?: number,
      y?: number,
      key?: string | RenderTexture | BitmapData | Video | PIXI.Texture,
      frame?: string | number,
    ): boolean,
    explode(lifespan?: number, quantity?: number): Particles$Arcade$Emitter,
    flow(
      lifespan?: number,
      frequency?: number,
      quantity?: number,
      total?: number,
      immediate?: boolean,
    ): Particles$Arcade$Emitter,
    kill(): Particles$Arcade$Emitter,
    makeParticles(
      keys: any,
      frames?: any,
      quantity?: number,
      collide?: boolean,
      collideWorldBounds?: boolean,
    ): Particles$Arcade$Emitter,
    reset(x: number, y: number, health?: number): Particles,
    setAlpha(
      min?: number,
      max?: number,
      rate?: number,
      ease?: (k: number) => number,
      yoyo?: boolean,
    ): Particles$Arcade$Emitter,
    setRotation(min?: number, max?: number): Particles$Arcade$Emitter,
    setScale(
      minX?: number,
      maxX?: number,
      minY?: number,
      maxY?: number,
      rate?: number,
      ease?: (k: number) => number,
      yoyo?: boolean,
    ): Particles$Arcade$Emitter,
    setSize(width: number, height: number): Particles$Arcade$Emitter,
    setXSpeed(min: number, max: number): Particles$Arcade$Emitter,
    setYSpeed(min: number, max: number): Particles$Arcade$Emitter,
    start(
      explode?: boolean,
      lifespan?: number,
      frequency?: number,
      quantity?: number,
      forceQuantity?: boolean,
    ): Particles$Arcade$Emitter,
    update(): void,
    revive(): Particles$Arcade$Emitter,
  }

  declare class Physics {
    constructor(game: Game, config?: any): this,
    ARCADE: number,
    P2JS: number,
    NINJA: number,
    BOX2D: number,
    CHIPMUNK: number,
    MATTERJS: number,
    arcade: Physics$Arcade,
    config: any,
    game: Game,
    ninja: Physics$Ninja,
    p2: Physics$P2,
    box2d: any,
    clear(): void,
    destroy(): void,
    enable(object: any, system?: number, debug?: boolean): void,
    parseConfig(): void,
    preUpdate(): void,
    reset(): void,
    setBoundsToWorld(): void,
    startSystem(system: number): void,
    update(): void,
  }

  declare class Video {
    game: Game,
    key: string,
    video: HTMLVideoElement,
    baseTexture: PIXI.BaseTexture,
    texture: PIXI.Texture,
    textureFrame: Frame,
    type: number,
    disableTextureUpload: boolean,
    dirty: boolean,
    currentTime: number,
    duration: number,
    progress: number,
    mute: boolean,
    paused: boolean,
    volume: boolean,
    playbackRate: boolean,
    playing: boolean,
    loop: boolean,
    width: number,
    height: number,
    videoStream: any,
    isStreaming: boolean,
    snapshot: BitmapData,
    timeout: number,
    retryLimit: number,
    retry: number,
    retryInterval: number,
    onAccess: Signal,
    onError: Signal,
    onPlay: Signal,
    onComplete: Signal,
    onUpdate: Signal,
    onTimeout: Signal,
    touchLocked: boolean,
    complete: () => void,
    constructor(game: Game, key?: string, url?: string): this,
    add(object: Sprite | Sprite[] | Image | Image[]): Video,
    addToWorld(
      x?: number,
      y?: number,
      anchorX?: number,
      anchorY?: Number,
      scaleX?: number,
      scaleY?: number,
    ): Image,
    createVideoFromBlob(blob: Blob): Video,
    startMediaStream(
      captureAudio?: boolean,
      width?: number,
      height?: number,
    ): Video,
    createVideoFromURL(url: string, autoplay?: boolean): Video,
    changeSource(src: string, autoplay?: boolean): Video,
    connectToMediaStram(video: any, stream: any): Video,
    destroy(): void,
    play(loop?: boolean, playbackRate?: number): Video,
    playHandler(): void,
    render(): void,
    removeVideoElement(): void,
    resizeFrame(parent: any, width: number, height: number): void,
    setTouchLock(): void,
    grab(clear?: boolean, alpha?: number, blendMode?: string): BitmapData,
    stop(): void,
    unlock(): boolean,
    updateTexture(event?: any, width?: number, height?: number): void,
  }

  declare class Physics$Arcade {
    SORT_NONE: number,
    LEFT_RIGHT: number,
    RIGHT_LEFT: number,
    TOP_BOTTOM: number,
    BOTTOM_TOP: number,
    OVERLAP_BIAS: number,
    TILE_BIAS: number,
    constructor(game: Game): this,
    bounds: Rectangle,
    checkCollision: {
      up?: boolean,
      down?: boolean,
      left?: boolean,
      right?: boolean,
    },
    forceX: boolean,
    game: Game,
    gravity: Point,
    quadTree: QuadTree,
    maxObjects: number,
    maxLevels: number,
    skipQuadTree: boolean,
    sortDirection: number,
    accelerationFromRotation(
      rotation: number,
      speed?: number,
      point?: Point,
    ): Point,
    accelerateToObject(
      displayObject: any,
      destination: any,
      speed?: number,
      xSpeedMax?: number,
      ySpeedMax?: number,
    ): number,
    accelerateToPointer(
      displayObject: any,
      pointer?: Pointer,
      speed?: number,
      xSpeedMax?: number,
      ySpeedMax?: number,
    ): number,
    accelerateToXY(
      displayObject: any,
      x: number,
      y: number,
      speed?: number,
      xSpeedMax?: number,
      ySpeedMax?: number,
    ): number,
    angleBetween(source: any, target: any, world?: boolean): number,
    angleToPointer(
      displayObject: any,
      pointer?: Pointer,
      world?: boolean,
    ): number,
    angleToXY(
      displayObject: any,
      x: number,
      y: number,
      world?: boolean,
    ): number,
    collide(
      object1: any,
      object2?: any,
      collideCallback?: Function,
      processCallback?: Function,
      callbackContext?: any,
    ): boolean,
    computeVelocity(
      axis: number,
      body: Physics$Arcade$Body,
      velocity: number,
      acceleration: number,
      drag: number,
      max?: number,
    ): number,
    distanceBetween(source: any, target: any, world?: boolean): number,
    distanceToPointer(
      displayObject: any,
      pointer?: Pointer,
      world?: boolean,
    ): number,
    distanceToXY(
      displayObject: any,
      x: number,
      y: number,
      world?: boolean,
    ): number,
    enable(object: any, children?: Boolean): void,
    enableBody(object: any): void,
    getObjectsAtLocation(
      x: number,
      y: number,
      group: Group,
      callback?: (callbackArg: any, object: any) => void,
      callbackContext?: any,
      callbackArg?: any,
    ): Sprite[],
    getOverlapX(body1: Physics$Arcade$Body, body2: Physics$Arcade$Body): number,
    getOverlapY(body1: Physics$Arcade$Body, body2: Physics$Arcade$Body): number,
    intersects(body1: Physics$Arcade$Body, body2: Physics$Arcade$Body): boolean,
    moveToObject(
      displayObject: any,
      destination: any,
      speed?: number,
      maxTime?: number,
    ): number,
    moveToPointer(
      displayObject: any,
      speed?: number,
      pointer?: Pointer,
      maxTime?: number,
    ): number,
    moveToXY(
      displayObject: any,
      x: number,
      y: number,
      speed?: number,
      maxTime?: number,
    ): number,
    overlap(
      object1: any,
      object2: any,
      overlapCallback?: Function,
      processCallback?: Function,
      callbackContext?: any,
    ): boolean,
    processTileSeparationX(body: Physics$Arcade$Body, x: number): boolean,
    processTileSeparationY(body: Physics$Arcade$Body, y: number): void,
    setBounds(x: number, y: number, width: number, height: number): void,
    setBoundsToWorld(): void,
    separate(
      body1: Physics$Arcade$Body,
      body2: Physics$Arcade$Body,
      processCallback?: Function,
      callbackContext?: any,
      overlapOnly?: boolean,
    ): boolean,
    separateX(
      body1: Physics$Arcade$Body,
      body2: Physics$Arcade$Body,
      overlapOnly: boolean,
    ): boolean,
    separateY(
      body1: Physics$Arcade$Body,
      body2: Physics$Arcade$Body,
      overlapOnly: boolean,
    ): boolean,
    separateTile(i: number, body: Physics$Arcade$Body, tile: Tile): boolean,
    sort(group: Group): void,
    tileCheckX(body: Physics$Arcade$Body, tile: Tile): number,
    tileCheckY(body: Physics$Arcade$Body, tile: Tile): number,
    updateMotion(body: Physics$Arcade$Body): void,
    velocityFromAngle(angle: number, speed?: number, point?: Point): Point,
    velocityFromRotation(
      rotation: number,
      speed?: number,
      point?: Point,
    ): Point,
  }

  declare class Physics$Arcade$Body {
    constructor(sprite: Sprite): this,
    acceleration: Point,
    allowGravity: boolean,
    allowRotation: boolean,
    angle: number,
    angularAcceleration: number,
    angularDrag: number,
    angularVelocity: number,
    blocked: Physics$Arcade$FaceChoices,
    bottom: number,
    bounce: Point,
    center: Point,
    checkCollision: Physics$Arcade$FaceChoices,
    collideWorldBounds: boolean,
    customSeparateX: boolean,
    customSeparateY: boolean,
    deltaMax: Point,
    dirty: boolean,
    drag: Point,
    embedded: boolean,
    enable: boolean,
    facing: number,
    friction: Point,
    game: Game,
    gravity: Point,
    halfWidth: number,
    halfHeight: number,
    height: number,
    immovable: boolean,
    isCircle: boolean,
    isMoving: boolean,
    mass: number,
    maxAngular: number,
    maxVelocity: Point,
    moves: boolean,
    movementCallback: any,
    movementCallbackContext: any,
    newVelocity: Point,
    offset: Point,
    onCollide: Signal,
    onMoveComplete: Signal,
    onOverlap: Signal,
    onWorldBounds: Signal,
    overlapX: number,
    overlapY: number,
    phase: number,
    position: Point,
    preRotation: number,
    prev: Point,
    radius: number,
    right: number,
    rotation: number,
    skipQuadTree: boolean,
    sourceWidth: number,
    sourceHeight: number,
    speed: number,
    sprite: Sprite,
    stopVelocityOnCollide: boolean,
    syncBounds: boolean,
    tilePadding: Point,
    touching: Physics$Arcade$FaceChoices,
    type: number,
    wasTouching: Physics$Arcade$FaceChoices,
    width: number,
    worldBounce: Point,
    velocity: Point,
    x: number,
    y: number,
    checkWorldBounds(): void,
    deltaX(): number,
    deltaY(): number,
    deltaZ(): number,
    deltaAbsX(): number,
    deltaAbsY(): number,
    destroy(): void,
    getBounds(obj: any): any,
    hitTest(x: number, y: number): boolean,
    moveFrom(duration: number, speed?: number, direction?: number): boolean,
    moveTo(duration: number, distance: number, direction?: number): boolean,
    onFloor(): boolean,
    onWall(): boolean,
    preUpdate(): void,
    postUpdate(): void,
    render(
      context: any,
      body: Physics$Arcade$Body,
      color?: string,
      filled?: boolean,
    ): void,
    renderBodyInfo(debug: Utils$Debug, body: Physics$Arcade$Body): void,
    reset(x: number, y: number): void,
    setCircle(radius: number, offsetX?: number, offsetY?: number): void,
    setSize(
      width: number,
      height: number,
      offsetX?: number,
      offsetY?: number,
    ): void,
    updateBounds(): boolean,
  }

  declare class Physics$Arcade$FaceChoices {
    none: boolean,
    any: boolean,
    up: boolean,
    down: boolean,
    left: boolean,
    right: boolean,
  }

  declare class Physics$Ninja {
    constructor(game: Game): this,
    game: Game,
    gravity: number,
    bounds: Rectangle,
    maxObjects: number,
    maxLevels: number,
    quadTree: QuadTree,
    time: Time,
    clearTilemapLayerBodies(map: Tilemap, layer: any): void,
    collide(
      object1: any,
      object2: any,
      collideCallback?: Function,
      processCallback?: Function,
      callbackContext?: any,
    ): boolean,
    convertTilemap(
      map: Tilemap,
      layer: any,
      slopeMap: any,
    ): Physics$Ninja$Tile[],
    enableAABB(object: any, children?: boolean): void,
    enableCircle(object: any, radius: number, children?: boolean): void,
    enableTile(object: any, id: number, children?: boolean): void,
    enable(
      object: any,
      type?: number,
      id?: number,
      radius?: number,
      children?: boolean,
    ): void,
    enableBody(object: any, type?: number, id?: number, radius?: number): void,
    overlap(
      object1: any,
      object2: any,
      overlapCallback?: Function,
      processCallback?: Function,
      callbackContext?: any,
    ): boolean,
    separate(
      body1: Physics$Ninja$Body,
      body2: Physics$Ninja$Body,
      processCallback?: Function,
      callbackContext?: any,
      overlapOnly?: boolean,
    ): boolean,
    setBounds(x: number, y: number, width: number, height: number): void,
    setBoundsToWorld(): void,
  }

  declare class Physics$Ninja$Body {
    constructor(
      system: Physics$Ninja,
      sprite: Sprite,
      type?: number,
      id?: number,
      radius?: number,
      x?: number,
      y?: number,
      width?: number,
      height?: number,
    ): this,
    aabb: Physics$Ninja$AABB,
    angle: number,
    bottom: number,
    bounce: number,
    checkCollision: Physics$Arcade$FaceChoices,
    circle: Physics$Ninja$Circle,
    collideWorldBounds: boolean,
    drag: number,
    facing: number,
    friction: number,
    game: Game,
    gravityScale: number,
    height: number,
    immovable: boolean,
    maxSpeed: number,
    right: number,
    sprite: Sprite,
    system: Physics$Ninja,
    tile: Physics$Ninja$Tile,
    touching: Physics$Arcade$FaceChoices,
    type: number,
    shape: any,
    speed: number,
    velocity: Point,
    wasTouching: Physics$Arcade$FaceChoices,
    width: number,
    x: number,
    y: number,
    deltaAbsX(): number,
    deltaAbsY(): number,
    deltaX(): number,
    deltaY(): number,
    destroy(): void,
    setZeroVelocity(): void,
    moveTo(speed: number, angle: number): void,
    moveFrom(speed: number, angle: number): void,
    moveLeft(speed: number): void,
    moveRight(speed: number): void,
    moveUp(speed: number): void,
    moveDown(speed: number): void,
    poseUpdate(): void,
    preUpdate(): void,
    render(
      context: any,
      body: Physics$Ninja$Body,
      color?: string,
      filled?: boolean,
    ): void,
    reset(): void,
  }

  declare class Physics$Ninja$AABB {
    constructor(
      body: Physics$Ninja$Body,
      x: number,
      y: number,
      width: number,
      height: number,
    ): this,
    COL_NONE: number,
    COL_AXIS: number,
    COL_OTHER: number,
    aabbTileProjections: any,
    body: Physics$Ninja$Body,
    height: number,
    oldPos: Point,
    pos: Point,
    system: Physics$Ninja,
    width: number,
    velocity: Point,
    xw: number,
    yw: number,
    collideWorldBounds(): void,
    collideAABBVsAABB(aabb: Physics$Ninja$AABB): boolean,
    collideAABBVsTile(tile: Physics$Ninja$Tile): boolean,
    destroy(): void,
    integrate(): void,
    render(
      context: any,
      xOffset: number,
      yOffset: number,
      color: string,
      filled: boolean,
    ): void,
    reportCollision(px: number, py: number, dx: number, dy: number): void,
    reportCollisionVsWorld(
      px: number,
      py: number,
      dx: number,
      dy: number,
      obj: any,
    ): void,
    reportCollisionVsBody(
      px: number,
      py: number,
      dx: number,
      dy: number,
      obj: any,
    ): void,
    resolveTile(
      x: number,
      y: number,
      body: Physics$Ninja$AABB,
      tile: Physics$Ninja$Tile,
    ): boolean,
    reverse(): void,
  }

  declare class Physics$Ninja$Circle {
    constructor(
      body: Physics$Ninja$Body,
      x: number,
      y: number,
      radius: number,
    ): this,
    COL_NONE: number,
    COL_AXIS: number,
    COL_OTHER: number,
    body: Physics$Ninja$Body,
    circleTileProjections: {
      [index: number]: (
        x: number,
        y: number,
        oH: number,
        oV: number,
        obj: Physics$Ninja$Circle,
        t: Physics$Ninja$Tile,
      ) => number,
    },
    oldPos: Point,
    height: number,
    pos: Point,
    radius: number,
    system: Physics$Ninja,
    type: number,
    velocity: Point,
    width: number,
    xw: number,
    yw: number,
    collideCircleVsTile(tile: Physics$Ninja$Tile): boolean,
    collideWorldBounds(): void,
    destroy(): void,
    distance(dest: number, round?: boolean): number,
    integrate(): void,
    render(
      context: any,
      xOffset: number,
      yOffset: number,
      color: string,
      filled: boolean,
    ): void,
    reportCollisionVsWorld(
      px: number,
      py: number,
      dx: number,
      dy: number,
      obj: any,
    ): void,
    reportCollisionVsBody(
      px: number,
      py: number,
      dx: number,
      dy: number,
      obj: any,
    ): void,
    resolveCircleTile(
      x: number,
      y: number,
      oH: number,
      oV: number,
      obj: Physics$Ninja$Circle,
      t: Physics$Ninja$Tile,
    ): boolean,
  }

  declare class Physics$Ninja$Tile {
    constructor(
      body: Physics$Ninja$Body,
      x: number,
      y: number,
      width: number,
      height: number,
      type?: number,
    ): this,
    body: Physics$Ninja$Body,
    bottom: number,
    flipped: boolean,
    height: number,
    id: number,
    oldpos: Point,
    pos: Point,
    right: number,
    rotation: number,
    system: Physics$Ninja,
    type: Physics$Ninja$TileType,
    velocity: Point,
    width: number,
    xw: number,
    yw: number,
    x: number,
    y: number,
    clear(): void,
    collideWorldBounds(): void,
    destroy(): void,
    integrate(): void,
    reportCollisionVsWorld(
      px: number,
      py: number,
      dx: number,
      dy: number,
      obj: any,
    ): void,
    setType(id: number): number,
  }

  declare class Physics$P2 {
    constructor(game: Game, config?: any): this,
    applyDamping: boolean,
    applyGravity: boolean,
    applySpringForces: boolean,
    boundsCollidesWith: Physics$P2$Body[],
    boundsCollisionGroup: Physics$P2$CollisionGroup,
    config: any,
    callbackContext: any,
    collisionGroups: Physics$P2$CollisionGroup[],
    contactMaterial: Physics$P2$ContactMaterial,
    emitImpactEvent: boolean,
    everythingCollisionGroup: Physics$P2$CollisionGroup,
    frameRate: number,
    friction: number,
    game: Game,
    gravity: Physics$P2$InversePointProxy,
    materials: Physics$P2$Material[],
    nothingCollisionGroup: Physics$P2$CollisionGroup,
    onBodyAdded: Signal,
    onBodyRemoved: Signal,
    onBeginContact: Signal,
    onConstraintAdded: Signal,
    onConstraintRemoved: Signal,
    onContactMaterialAdded: Signal,
    onContactMaterialRemoved: Signal,
    onEndContact: Signal,
    onSpringAdded: Signal,
    onSpringRemoved: Signal,
    paused: boolean,
    postBroaddphaseCallback: Function,
    restitution: number,
    solveConstraints: boolean,
    time: any,
    total: number,
    useElapsedTime: boolean,
    walls: {
      left?: Physics$P2$Body,
      right?: Physics$P2$Body,
      top?: Physics$P2$Body,
      bottom?: Physics$P2$Body,
    },
    world: p2.World,
    addBody(body: Physics$P2$Body): boolean,
    addContactMaterial(
      material: Physics$P2$ContactMaterial,
    ): Physics$P2$ContactMaterial,
    addConstraint<T>(constraint: T): T,
    addSpring(spring: Physics$P2$Spring): Physics$P2$Spring,
    beginContactHandler(event: any): void,
    clear(): void,
    clearTilemapLayerBodies(map: Tilemap, layer?: any): void,
    convertCollisionObjects(
      map: Tilemap,
      layer?: any,
      addToWorld?: boolean,
    ): Physics$P2$Body[],
    convertTilemap(
      map: Tilemap,
      layer?: any,
      addToWorld?: Boolean,
      optimize?: boolean,
    ): Physics$P2$Body[],
    createBody(
      x: number,
      y: number,
      mass: number,
      addToWorld?: boolean,
      options?: p2.BodyOptions,
      data?: number[][],
    ): Physics$P2$Body,
    createBody(
      x: number,
      y: number,
      mass: number,
      addToWorld?: boolean,
      options?: p2.BodyOptions,
      data?: number[],
    ): Physics$P2$Body,
    createCollisionGroup(group?: Group): Physics$P2$CollisionGroup,
    createCollisionGroup(group?: Sprite): Physics$P2$CollisionGroup,
    createContactMaterial(
      materialA: Physics$P2$Material,
      materialB: Physics$P2$Material,
      options?: p2.ContactMaterialOptions,
    ): Physics$P2$ContactMaterial,
    createDistanceConstraint(
      bodyA: any,
      bodyB: any,
      distance: number,
      localAnchorA?: number[],
      localAnchorB?: number[],
      maxForce?: number,
    ): Physics$P2$DistanceConstraint,
    createGearConstraint(
      bodyA: any,
      bodyB: any,
      angle?: number,
      ratio?: number,
    ): Physics$P2$GearConstraint,
    createLockConstraint(
      bodyA: any,
      bodyB: any,
      offset?: number[],
      angle?: number,
      maxForce?: number,
    ): Physics$P2$LockConstraint,
    createMaterial(name?: string, body?: Physics$P2$Body): Physics$P2$Material,
    createParticle(
      x: number,
      y: number,
      mass: number,
      addToWorld?: boolean,
      options?: p2.BodyOptions,
      data?: number[][],
    ): Physics$P2$Body,
    createParticle(
      x: number,
      y: number,
      mass: number,
      addToWorld?: boolean,
      options?: p2.BodyOptions,
      data?: number[],
    ): Physics$P2$Body,
    createPrismaticConstraint(
      body: any,
      bodyB: any,
      lockRotation?: boolean,
      anchorA?: number[],
      anchorB?: number[],
      axis?: Float32Array,
      maxForce?: number,
    ): Physics$P2$PrismaticConstraint,
    createRevoluteConstraint(
      bodyA: any,
      pivotA: number[],
      bodyB: any,
      pivotB: number[],
      maxForce?: number,
      worldPivot?: number[],
    ): Physics$P2$RevoluteConstraint,
    createRotationalSpring(
      bodyA: any,
      bodyB: any,
      restAngle?: number,
      stiffness?: number,
      damping?: number,
    ): p2.RotationalSpring,
    createSpring(
      bodyA: any,
      bodyB: any,
      restLength?: number,
      stiffness?: number,
      damping?: number,
      worldA?: number[],
      worldB?: number[],
      localA?: number[],
      localB?: number[],
    ): Physics$P2$Spring,
    destroy(): void,
    enable(object: any, debug?: boolean, children?: boolean): void,
    enableBody(object: any, debug: boolean): void,
    endContactHandler(event: any): void,
    getBodies(): Physics$P2$Body[],
    getBody(object: any): Physics$P2$Body,
    getConstraints(): p2.Constraint[],
    getSprings(): Physics$P2$Spring[],
    getContactMaterial(
      materialA: Physics$P2$Material,
      materialB: Physics$P2$Material,
    ): Physics$P2$ContactMaterial,
    hitTest(
      worldPoint: Point,
      bodies?: any[],
      precision?: number,
      filterStatic?: boolean,
    ): Physics$P2$Body[],
    mpx(v: number): number,
    mpxi(v: number): number,
    pause(): void,
    preUpdate(): void,
    pxm(v: number): number,
    pxmi(v: number): number,
    removeBody(body: Physics$P2$Body): Physics$P2$Body,
    removeBodyNextStep(body: Physics$P2$Body): void,
    removeConstraint<T>(constraint: T): T,
    removeContactMaterial(
      material: Physics$P2$ContactMaterial,
    ): Physics$P2$ContactMaterial,
    removeSpring(spring: Physics$P2$Spring): Physics$P2$Spring,
    reset(): void,
    resume(): void,
    setBounds(
      x: number,
      y: number,
      width: number,
      height: number,
      left?: Boolean,
      right?: boolean,
      top?: boolean,
      bottom?: boolean,
      setCollisionGroup?: boolean,
    ): void,
    setBoundsToWorld(
      left?: boolean,
      right?: boolean,
      top?: boolean,
      bottom?: boolean,
      setCollisionGroup?: boolean,
    ): void,
    setCollisionGroup(object: any, group: Physics$P2$CollisionGroup): void,
    setImpactEvents(state: boolean): void,
    setMaterial(
      material: Physics$P2$Material,
      bodies?: Physics$P2$Body[],
    ): void,
    setPostBroadphaseCallback(callback: Function, context: any): void,
    setWorldMaterial(
      material: Physics$P2$Material,
      left?: boolean,
      right?: boolean,
      top?: boolean,
      bottom?: boolean,
    ): void,
    toJSON(): any,
    update(): void,
    updateBoundsCollisionGroup(setCollisionGroup?: boolean): void,
  }

  declare class Physics$P2$Body {
    ['static']: boolean,
    DYNAMIC: number,
    STATIC: number,
    KINEMATIC: number,
    constructor(
      game: Game,
      sprite?: Sprite,
      x?: number,
      y?: number,
      mass?: number,
    ): this,
    allowSleep: boolean,
    angle: number,
    angularDamping: number,
    angularForce: number,
    angularVelocity: number,
    collidesWith: Physics$P2$CollisionGroup[],
    collideWorldBounds: boolean,
    damping: number,
    data: p2.Body,
    debug: boolean,
    debugBody: Physics$P2$BodyDebug,
    dynamic: boolean,
    fixedRotation: boolean,
    force: Physics$P2$InversePointProxy,
    kinematic: boolean,
    game: Game,
    gravity: Point,
    id: number,
    inertia: number,
    mass: number,
    motionState: number,
    offset: Point,
    onBeginContact: Signal,
    onEndContact: Signal,
    rotation: number,
    removeNextStep: boolean,
    sprite: Sprite,
    sleepSpeedLimit: number,
    type: number,
    velocity: Physics$P2$InversePointProxy,
    world: Physics$P2,
    x: number,
    y: number,
    addToWorld(): void,
    addCapsule(
      length: number,
      radius: number,
      offsetX?: number,
      offsetY?: number,
      rotation?: number,
    ): p2.Capsule,
    addCircle(
      radius: number,
      offsetX?: number,
      offsetY?: number,
      rotation?: number,
    ): p2.Circle,
    addFixture(fixtureData: string): p2.Shape[],
    addLine(
      length: number,
      offsetX?: number,
      offsetY?: number,
      rotation?: number,
    ): p2.Line,
    addParticle(
      offsetX?: number,
      offsetY?: number,
      rotation?: number,
    ): p2.Particle,
    addPolygon(
      options: {
        optimalDecomp?: boolean,
        skipSimpleCheck?: boolean,
        removeCollinearPoints?: boolean,
      },
      points: number[][],
    ): boolean,
    addPhaserPolygon(key: string, object: string): Physics$P2$FixtureList,
    addPlane(offsetX?: number, offsetY?: number, rotation?: number): p2.Plane,
    addRectangle(
      width: number,
      height: number,
      offsetX?: number,
      offsetY?: number,
      rotation?: number,
    ): p2.Rectangle,
    addShape(
      shape: p2.Shape,
      offsetX?: number,
      offsetY?: number,
      rotation?: number,
    ): p2.Shape,
    adjustCenterOfMass(): void,
    applyDamping(dt: number): void,
    applyForce(force: number[], worldX: number, worldY: number): void,
    applyImpulse(impulse: number[], worldX: number, worldY: number): void,
    applyImpulseLocal(impulse: number[], localX: number, localY: number): void,
    clearCollision(
      clearGroup?: boolean,
      cleanMask?: boolean,
      shape?: p2.Shape,
    ): void,
    clearShapes(): void,
    collides(
      group: any,
      callback?: Function,
      callbackContext?: any,
      shape?: p2.Shape,
    ): void,
    createBodyCallback(
      object: any,
      callback: Function,
      callbackContext: any,
    ): void,
    createGroupCallback(
      group: Physics$P2$CollisionGroup,
      callback: Function,
      callbackContext: any,
    ): void,
    destroy(): void,
    getCollisionMask(): number,
    getVelocityAtPoint(result: number[], relativePoint: number[]): number[],
    loadPolygon(key: string, object: string): boolean,
    moveBackward(speed: number): void,
    moveDown(speed: number): void,
    moveForward(speed: number): void,
    moveLeft(speed: number): void,
    moveRight(speed: number): void,
    moveUp(speed: number): void,
    preUpdate(): void,
    postUpdate(): void,
    removeCollisionGroup(
      group: any,
      clearCallback?: boolean,
      shape?: p2.Shape,
    ): void,
    removeFromWorld(): void,
    removeShape(shape: p2.Shape): boolean,
    reverse(speed: number): void,
    rotateLeft(speed: number): void,
    rotateRight(speed: number): void,
    reset(
      x: number,
      y: number,
      resetDamping?: boolean,
      resetMass?: boolean,
    ): void,
    shapeChanged(): void,
    setCircle(
      radius: number,
      offsetX?: number,
      offsetY?: number,
      rotation?: number,
    ): p2.Circle,
    setCollisionGroup(group: Physics$P2$CollisionGroup, shape?: p2.Shape): void,
    setRectangle(
      width?: number,
      height?: number,
      offsetX?: number,
      offsetY?: number,
      rotation?: number,
    ): p2.Rectangle,
    setRectangleFromSprite(sprite: any): p2.Rectangle,
    setMaterial(material: Physics$P2$Material, shape?: p2.Shape): void,
    setZeroDamping(): void,
    setZeroForce(): void,
    setZeroRotation(): void,
    setZeroVelocity(): void,
    toLocalFrame(out: number[], worldPoint: number[]): void,
    thrust(speed: number): void,
    thrustLeft(speed: number): void,
    thrustRight(speed: number): void,
    toWorldFrame(out: number[], localPoint: number[]): void,
    updateCollisionMask(shape?: p2.Shape): void,
  }

  declare class Physics$P2$BodyDebug extends Group {
    constructor(
      game: Game,
      body: Physics$P2$Body,
      settings: {
        pixelsPerLengthUnit?: number,
        debugPolygons?: boolean,
        lineWidth?: number,
        alpha?: number,
      },
    ): this,
    body: Physics$P2$Body,
    canvas: Graphics,
    ppu: number,
    updateSpriteTransform(): void,
    draw(): void,
  }

  declare class Physics$P2$CollisionGroup {
    constructor(bitmask: number): this,
    mask: number,
  }

  declare class Physics$P2$ContactMaterial extends p2.ContactMaterial {}

  declare class Physics$P2$DistanceConstraint extends p2.DistanceConstraint {
    constructor(
      world: Physics$P2,
      bodyA: Physics$P2$Body,
      bodyB: Physics$P2$Body,
      distance: number,
      maxForce: number,
    ): this,
    game: Game,
    world: Physics$P2,
  }

  declare class Physics$P2$FixtureList {
    constructor(list: any[]): this,
    flatten(array: any[]): any[],
    getFixtures(keys: string): any[],
    getFixtureByKey(key: string): any[],
    getGroup(groupID: number): any[],
    init(): void,
    parse(): void,
    setCategory(bit: number, fictureKey: string): void,
    setMask(bit: number, fixtureKey: string): void,
    setMaterial(material: any, fixtureKey: string): void,
    setSensor(value: boolean, fixtureKey: string): void,
  }

  declare class Physics$P2$GearConstraint extends p2.GearConstraint {
    constructor(
      world: Physics$P2,
      bodyA: Physics$P2$Body,
      bodyB: Physics$P2$Body,
      angle?: number,
      ratio?: number,
    ): this,
    game: Game,
    world: Physics$P2,
  }

  declare class Physics$P2$InversePointProxy {
    constructor(world: Physics$P2, destination: any): this,
    x: number,
    y: number,
    mx: number,
    my: number,
  }

  declare class Physics$P2$LockConstraint extends p2.LockConstraint {
    constructor(
      world: Physics$P2,
      bodyA: Physics$P2$Body,
      bodyB: Physics$P2$Body,
      offset?: number[],
      angle?: number,
      maxForce?: number,
    ): this,
    game: Game,
    world: Physics$P2,
  }

  declare class Physics$P2$Material extends p2.Material {
    constructor(name: string): this,
    name: string,
  }

  declare class Physics$P2$PointProxy {
    constructor(world: Physics$P2, destination: any): this,
    x: number,
    y: number,
    mx: number,
    my: number,
  }

  declare class Physics$P2$PrismaticConstraint extends p2.PrismaticConstraint {
    constructor(
      world: Physics$P2,
      bodyA?: Physics$P2$Body,
      bodyB?: Physics$P2$Body,
      lockRotation?: boolean,
      anchorA?: number[],
      anchorB?: number[],
      axis?: number[],
      maxForce?: number,
    ): this,
    game: Game,
    world: Physics$P2,
  }

  declare class Physics$P2$RevoluteConstraint extends p2.RevoluteConstraint {
    constructor(
      world: Physics$P2,
      bodyA: Physics$P2$Body,
      pivotA: number[],
      bodyB: Physics$P2$Body,
      pivotB: number[],
      maxForce?: number,
    ): this,
    game: Game,
    world: Physics$P2,
  }

  declare class Physics$P2$Spring {
    constructor(
      world: Physics$P2,
      bodyA: Physics$P2$Body,
      bodyB: Physics$P2$Body,
      restLength?: number,
      stiffness?: number,
      damping?: number,
      worldA?: number[],
      worldB?: number[],
      localA?: number[],
      localB?: number[],
    ): this,
    data: p2.LinearSpring,
    game: Game,
    world: Physics$P2,
  }

  declare class Plugin {
    constructor(game: Game, parent: PluginManager): this,
    active: boolean,
    game: Game,
    hasPostRender: boolean,
    hasPostUpdate: boolean,
    hasPreUpdate: boolean,
    hasRender: boolean,
    hasUpdate: boolean,
    parent: PIXI.DisplayObject,
    visible: boolean,
    destroy(): void,
    postRender(): void,
    preUpdate(): void,
    render(): void,
    update(): void,
  }

  declare class Plugin$SaveCPU extends Plugin {
    renderOnFPS: number,
    renderOnPointerChange: boolean,
    forceRender(): void,
  }

  declare class Plugin$AStar extends Plugin {
    VERSION: string,
    COST_ORTHOGONAL: number,
    COST_DIAGONAL: number,
    DISTANCE_MANHATTEN: string,
    DISTANCE_EUCLIDIAN: string,
    constructor(parent: PIXI.DisplayObject): this,
    parent: PIXI.DisplayObject,
    version: string,
    findPath(startPoint: Point, goalPoint: Point): Plugin$AStar$AStarPath,
    isWalkable(x: number, y: number): boolean,
    setAStarMap(
      map: Tilemap,
      layerName: string,
      tilesetName: string,
    ): Plugin$AStar,
  }

  declare class Plugin$AStar$AStarNode {
    constructor(x: number, y: number, isWalkable: boolean): this,
    x: number,
    y: number,
    g: number,
    h: number,
    f: number,
    parent: Plugin$AStar$AStarNode,
    travelCost: number,
    walkable: boolean,
  }

  declare class Plugin$AStar$AStarPath {
    constructor(
      nodes?: {
        x: number,
        y: number,
      }[],
      start?: Plugin$AStar$AStarNode,
      goal?: Plugin$AStar$AStarNode,
    ): this,
    nodes: {
      x: number,
      y: number,
    }[],
    start: Plugin$AStar$AStarNode,
    goal: Plugin$AStar$AStarNode,
    visited: Plugin$AStar$AStarNode[],
  }

  declare class ColorHarmony extends Plugin {
    getAnalogousHarmony(color: number, threshold?: number): any,
    getComplementHarmony(color: number): number,
    getSplitComplementHarmony(color: number, threshold: number): any,
    getTriadicHarmony(color: number): any,
  }

  declare class CSS3Filters extends Plugin {
    constructor(parent: PIXI.DisplayObject): this,
    blur: number,
    brightness: number,
    contrast: number,
    grayscale: number,
    hueRotate: number,
    invert: number,
    opacity: number,
    saturate: number,
    sepia: number,
  }

  declare class TilemapWalker extends Plugin {
    constructor(
      game: Game,
      map: Tilemap,
      layer?: any,
      x?: number,
      y?: number,
    ): this,
    collides: boolean,
    game: Game,
    history: boolean,
    facing: number,
    map: Tilemap,
    location: Point,
    locationLayer: number,
    checkTile(x: number, y: number): boolean,
    getTileFromLocation(x: number, y: number): Tile,
    getTiles(width: number, height: number, center?: boolean): any[],
    getTileBehind(distance?: number): Tile,
    getTileBehindLeft(distance?: number): Tile,
    getTileBehindRight(distance?: number): Tile,
    getTileAhead(distance?: number): Tile,
    getTileAheadLeft(distance?: number): Tile,
    getTileAheadRight(distance?: number): Tile,
    getTileLeft(distance: number): Tile,
    getTileRight(distance: number): Tile,
    moveForward(): boolean,
    moveBackward(): boolean,
    moveLeft(): boolean,
    moveRight(): boolean,
    putTile(index: number): void,
    setLocation(x: number, y: number, layer?: any): boolean,
    turnLeft(): void,
    turnRight(): void,
    updateLocation(x: number, y: number): boolean,
  }

  declare class SamplePlugin extends Plugin {
    constructor(game: Game, parent: PIXI.DisplayObject): this,
    addSprite(sprite: Sprite): void,
    update(): void,
  }

  declare class VirtualJoystick extends Plugin {
    constructor(game: Game, parent: any): this,
    angle: number,
    base: Sprite,
    baseBMD: BitmapData,
    baseCircle: Circle,
    deltaX: number,
    deltaY: number,
    distance: number,
    force: number,
    isDragging: boolean,
    limit: number,
    limitPoint: Point,
    location: Point,
    nub: Sprite,
    nubBMD: BitmapData,
    speed: number,
    x: number,
    y: number,
    init(x: number, y: number, diameter?: number, limit?: number): void,
    move(pointer: Pointer, x: number, y: number): void,
    render(): void,
    setVelocity(sprite: Sprite, minSpeed?: number, maxSpeed?: number): Sprite,
    startDrag(): void,
    stopDrag(nub: Sprite, pointer: Pointer): void,
    update(): void,
  }

  declare class Webcam extends Plugin {
    constructor(game: Game, parent: PIXI.DisplayObject): this,
    active: boolean,
    context: any,
    stream: any,
    video: HTMLVideoElement,
    connectCallback: (stream: any) => void,
    errorCallback: (e: any) => void,
    grab: (context: any, x: number, y: number) => void,
    start(width: number, height: number, context: any): void,
    stop(): void,
    update(): void,
  }

  declare class Plugin$Juicy extends Plugin {
    constructor(game: Game): this,
    createScreenFlash(color?: string): Plugin$Juicy$ScreenFlash,
    createTrail(length?: number, color?: number): Plugin$Juicy$Trail,
    overScale(object: Sprite, scale?: number, initialScale?: Point): void,
    jelly(
      object: Sprite,
      strength?: number,
      delay?: number,
      initialScale?: Point,
    ): void,
    mouseStretch(object: Sprite, strength?: number, initialScale?: Point): void,
    update(): void,
    shake(duration?: number, strength?: number): void,
  }

  declare class Plugin$Juicy$Trail {
    constructor(game: Game, trailLength?: number, color?: number): this,
    target: Sprite,
    trailLength: number,
    trailWidth: number,
    trailScaling: boolean,
    trailColor: number,
    update(): void,
    addSegment(x: number, y: number): void,
    redrawSegments(offsetX: number, offsetY: number): void,
  }

  declare class Plugin$Juicy$ScreenFlash {
    constructor(game: Game, color?: string): this,
    flash(maxAlpha?: number, duration?: number): void,
  }

  declare interface PluginConstructorOf<T> {
    new(...parameters: any[]): T,
  }

  declare class PluginManager {
    constructor(game: Game): this,
    game: Game,
    plugins: Plugin[],
    add<T>(plugin: PluginConstructorOf<T>, ...parameters: any[]): T,
    destroy(): void,
    postRender(): void,
    postUpdate(): void,
    preUpdate(): void,
    remove(plugin: Plugin, destroy?: boolean): void,
    removeAll(): void,
    render(): void,
    update(): void,
  }

  declare class Point extends PIXI.Point {
    constructor(x?: number, y?: number): this,
    x: number,
    y: number,
    type: number,
    add(a: Point, b: Point, out?: Point): Point,
    subtract(a: Point, b: Point, out?: Point): Point,
    multiply(a: Point, b: Point, out?: Point): Point,
    divide(a: Point, b: Point, out?: Point): Point,
    equals(a: Point, b: Point): boolean,
    angle(a: Point, b: Point): number,
    angleSq(a: Point, b: Point): number,
    negative(a: Point, out?: Point): Point,
    multiplyAdd(a: Point, b: Point, scale: number, out?: Point): Point,
    interpolate(a: Point, b: Point, alpha: number, out?: Point): Point,
    parse(obj: any, xProp?: string, yProp?: string): Point,
    perp(a: Point, out?: Point): Point,
    rperp(a: Point, out?: Point): Point,
    distance(a: any, b: any, round?: boolean): number,
    project(a: Point, b: Point, out?: Point): Point,
    projectUnit(a: Point, b: Point, out?: Point): Point,
    normalRightHand(a: Point, out?: Point): Point,
    normalize(a: Point, out?: Point): Point,
    rotate(
      a: Point,
      x: number,
      y: number,
      angle: number,
      asDegrees?: boolean,
      distance?: number,
    ): Point,
    centroid(points: Point[], out?: Point): Point,
    add(x: number, y: number): Point,
    angle(a: Point, asDegrees?: boolean): number,
    angleSq(a: Point): number,
    clamp(min: number, max: number): Point,
    clampX(min: number, max: number): Point,
    clampY(min: number, max: number): Point,
    clone(output?: Point): Point,
    copyFrom(source: Point): Point,
    copyTo<T>(dest: T): T,
    ceil(): Point,
    cross(a: Point): number,
    divide(x: number, y: number): Point,
    distance(dest: Point, round?: boolean): number,
    dot(a: Point): number,
    equals(a: Point): boolean,
    floor(): Point,
    getMagnitude(): number,
    getMagnitudeSq(): number,
    invert(): Point,
    isZero(): boolean,
    multiply(x: number, y: number): Point,
    normalize(): Point,
    normalRightHand(): Point,
    perp(): Point,
    rperp(): Point,
    rotate(
      x: number,
      y: number,
      angle: number,
      asDegrees?: boolean,
      distance?: number,
    ): Point,
    set(x: number, y?: number): Point,
    setMagnitude(magnitude: number): Point,
    setTo(x: number, y?: number): Point,
    subtract(x: number, y: number): Point,
    toString(): string,
  }

  declare class Pointer {
    constructor(game: Game, id: number, pointerMode?: number): this,
    NO_BUTTON: number,
    LEFT_BUTTON: number,
    RIGHT_BUTTON: number,
    MIDDLE_BUTTON: number,
    BACK_BUTTON: number,
    FORWARD_BUTTON: number,
    ERASER_BUTTON: number,
    active: boolean,
    backButton: DeviceButton,
    button: any,
    circle: Circle,
    clientX: number,
    clientY: number,
    dirty: boolean,
    duration: number,
    eraserButton: DeviceButton,
    exists: boolean,
    forceOut: boolean,
    forwardButton: DeviceButton,
    game: Game,
    justReleasePreventsOver: boolean | number,
    id: number,
    identifier: number,
    interactiveCandidates: InputHandler[],
    isDown: boolean,
    isMouse: boolean,
    isUp: boolean,
    leftButton: DeviceButton,
    middleButton: DeviceButton,
    movementX: number,
    movementY: number,
    msSinceLastClick: number,
    pageX: number,
    pageY: number,
    pointerId: number,
    pointerMode: number,
    position: Point,
    positionDown: Point,
    positionUp: Point,
    previousTapTime: number,
    rawMovementX: number,
    rawMovementY: number,
    rightButton: DeviceButton,
    screenX: number,
    screenY: number,
    target: any,
    targetObject: any,
    timeDown: number,
    timeUp: number,
    totalTouches: number,
    type: number,
    withinGame: boolean,
    worldX: number,
    worldY: number,
    x: number,
    y: number,
    addClickTrampoline(
      name: string,
      callback: Function,
      callbackContext: any,
      ...callbackArgs: any[]
    ): void,
    justPressed(duration?: number): boolean,
    justReleased(duration?: number): boolean,
    leave(event: any): void,
    move(event: any, fromClick?: boolean): void,
    reset(): void,
    resetButtons(): void,
    resetMovement(): void,
    start(event: any): void,
    stop(event: any): void,
    swapTarget(newTarget: InputHandler, silent?: boolean): void,
    update(): void,
    updateButtons(event: MouseEvent): void,
  }

  declare class Polygon {
    constructor(points: Point[] | number[]): this,
    constructor(...points: Point[]): this,
    constructor(...points: number[]): this,
    area: number,
    flattened: boolean,
    points: number[] | Point[],
    type: number,
    clone(output: Polygon): Polygon,
    contains(x: number, y: number): boolean,
    flatten(): Polygon,
    setTo(points: Point[] | number[]): void,
    setTo(...points: Point[]): void,
    setTo(...points: number[]): void,
    toNumberArray(output?: number[]): number[],
  }

  declare class QuadTree {
    constructor(
      x: number,
      y: number,
      width: number,
      height: number,
      maxObject?: number,
      maxLevels?: number,
      level?: number,
    ): this,
    bounds: {
      x: number,
      y: number,
      width: number,
      height: number,
      subWidth: number,
      subHeight: number,
      right: number,
      bottom: number,
    },
    level: number,
    maxObjects: number,
    maxLevels: number,
    objects: any[],
    nodes: any[],
    clear(): void,
    getIndex(rect: any): number,
    insert(body: any): void,
    populate(group: Group): void,
    populateHandler(sprite: Sprite): void,
    reset(
      x: number,
      y: number,
      width: number,
      height: number,
      maxObject?: number,
      maxLevels?: number,
      level?: number,
    ): void,
    retrieve(source: any): any[],
    split(): void,
  }

  declare class RandomDataGenerator {
    constructor(seeds?: any[] | string): this,
    angle(): number,
    between(min: number, max: number): number,
    frac(): number,
    integer(): number,
    integerInRange(min: number, max: number): number,
    normal(): number,
    pick<T>(ary: T[]): T,
    real(): number,
    realInRange(min: number, max: number): number,
    sign(): number,
    sow(seeds: any[]): void,
    state(state?: string): string,
    timestamp(min: number, max: number): number,
    uuid(): string,
    weightedPick<T>(ary: T[]): T,
  }

  declare class Rectangle {
    constructor(x: number, y: number, width: number, height: number): this,
    bottom: number,
    bottomRight: Point,
    bottomLeft: Point,
    centerX: number,
    centerY: number,
    empty: boolean,
    halfHeight: number,
    halfWidth: number,
    height: number,
    left: number,
    perimeter: number,
    randomX: number,
    randomY: number,
    right: number,
    top: number,
    topLeft: Point,
    topRight: Point,
    type: number,
    volume: number,
    width: number,
    x: number,
    y: number,
    aabb(points: Point[], out?: Rectangle): Rectangle,
    clone(a: Rectangle, output?: Rectangle): Rectangle,
    contains(a: Rectangle, x: number, y: number): boolean,
    containsPoint(a: Rectangle, point: Point): boolean,
    containsRaw(
      rx: number,
      ry: number,
      rw: number,
      rh: number,
      x: number,
      y: number,
    ): boolean,
    containsRect(a: Rectangle, b: Rectangle): boolean,
    equals(a: Rectangle, b: Rectangle): boolean,
    inflate(a: Rectangle, dx: number, dy: number): Rectangle,
    inflatePoint(a: Rectangle, point: Point): Rectangle,
    intersection(a: Rectangle, b: Rectangle, out?: Rectangle): Rectangle,
    intersects(a: Rectangle, b: Rectangle): boolean,
    intersectsRaw(
      left: number,
      right: number,
      top: number,
      bottom: number,
      tolerance: number,
    ): boolean,
    size(a: Rectangle, output?: Point): Point,
    union(a: Rectangle, b: Rectangle, out?: Rectangle): Rectangle,
    ceil(): void,
    ceilAll(): void,
    centerOn(x: number, y: number): Rectangle,
    clone(output: Rectangle): Rectangle,
    contains(x: number, y: number): boolean,
    containsRect(b: Rectangle): boolean,
    copyFrom(source: any): Rectangle,
    copyTo(dest: any): any,
    equals(b: Rectangle): boolean,
    floor(): void,
    floorAll(): void,
    getPoint(position: number, out: Point): Point,
    inflate(dx: number, dy: number): Rectangle,
    intersection(b: Rectangle, out: Rectangle): Rectangle,
    intersects(b: Rectangle, tolerance: number): boolean,
    intersectsRaw(
      left: number,
      right: number,
      top: number,
      bottom: number,
      tolerance: number,
    ): boolean,
    offset(dx: number, dy: number): Rectangle,
    offsetPoint(point: Point): Rectangle,
    random(out?: Point): Point,
    resize(width: number, height: number): Rectangle,
    setTo(x: number, y: number, width: number, height: number): Rectangle,
    scale(x: number, y?: number): Rectangle,
    size(output?: Point): Point,
    toString(): string,
    union(b: Rectangle, out?: Rectangle): Rectangle,
  }

  declare class RenderTexture extends PIXI.RenderTexture {
    constructor(
      game: Game,
      width?: number,
      height?: number,
      key?: string,
      scaleMode?: number,
      resolution?: number,
    ): this,
    crop: PIXI.Rectangle,
    game: Game,
    key: string,
    type: number,
    render(
      displayObject: PIXI.DisplayObject,
      matrix?: Matrix,
      clear?: boolean,
    ): void,
    renderXY(
      displayObject: PIXI.DisplayObject,
      x: number,
      y: number,
      clear?: boolean,
    ): void,
    renderRawXY(
      displayObject: PIXI.DisplayObject,
      x: number,
      y: number,
      clear?: boolean,
    ): void,
  }

  declare class RequestAnimationFrame {
    constructor(game: Game, forceSetTimeOut?: boolean): this,
    forceSetTimeOut: boolean,
    game: Game,
    isRunning: boolean,
    isRAF(): boolean,
    isSetTimeOut(): boolean,
    start(): boolean,
    stop(): void,
    updateRAF(rafTime: number): void,
    updateSetTimeout(time: number): void,
  }

  declare class RetroFont extends RenderTexture {
    constructor(
      game: Game,
      key: string,
      characterWidth: number,
      characterHeight: number,
      chars: string,
      charsPerRow?: number,
      xSpacing?: number,
      ySpacing?: number,
      xOffset?: number,
      yOffset?: number,
    ): this,
    ALIGN_CENTER: string,
    ALIGN_LEFT: string,
    ALIGN_RIGHT: string,
    TEXT_SET1: string,
    TEXT_SET2: string,
    TEXT_SET3: string,
    TEXT_SET4: string,
    TEXT_SET5: string,
    TEXT_SET6: string,
    TEXT_SET7: string,
    TEXT_SET8: string,
    TEXT_SET9: string,
    TEXT_SET10: string,
    TEXT_SET11: string,
    align: string,
    autoUpperCase: boolean,
    characterHeight: number,
    characterPerRow: number,
    characterSpacingX: number,
    characterSpacingY: number,
    characterWidth: number,
    customSpacingX: number,
    customSpacingY: number,
    fixedWidth: number,
    fontSet: Image,
    frameData: FrameData,
    multiLine: boolean,
    offsetX: number,
    offsetY: number,
    smoothed: boolean,
    stamp: Image,
    text: string,
    buildRetroFontText(): void,
    getLongestLine(): number,
    pasteLine(line: string, x: number, y: number, customSpacingX: number): void,
    removeUnsupportedCharacters(stripCR?: boolean): string,
    setFixedWidth(width: number, lineAlignment?: string): void,
    setText(
      content: string,
      multiLine?: boolean,
      characterSpacing?: number,
      lineSpacing?: number,
      lineAlignment?: string,
      allowLowerCase?: boolean,
    ): void,
    updateOffset(x?: number, y?: number): void,
  }

  declare class Rope extends PIXI.Rope {
    constructor(
      game: Game,
      x: number,
      y: number,
      key: string | RenderTexture | BitmapData | PIXI.Texture | Video,
      frame?: string | number,
      points?: Point[],
    ): this,
    angle: number,
    animations: AnimationManager,
    alive: boolean,
    autoCull: boolean,
    body: Any$Body,
    bottom: number,
    cameraOffset: Point,
    checkWorldBounds: boolean,
    cropRect: Rectangle,
    components: any,
    customRender: boolean,
    debug: boolean,
    deltaX: number,
    deltaY: number,
    deltaZ: number,
    destroyPhase: boolean,
    exists: boolean,
    events: Events,
    fixedToCamera: boolean,
    frame: string | number,
    frameName: string,
    fresh: boolean,
    game: Game,
    inCamera: boolean,
    input: InputHandler,
    inputEnabled: boolean,
    inWorld: boolean,
    left: number,
    lifespan: number,
    key: string | RenderTexture | BitmapData | PIXI.Texture | Video,
    name: string,
    offsetX: number,
    offsetY: number,
    outOfBoundsKill: boolean,
    overlap(
      displayObject: Sprite | Image | TileSprite | Button | PIXI.DisplayObject,
    ): boolean,
    pendingDestroy: boolean,
    points: Point[],
    position: Point,
    previousPosition: Point,
    previousRotation: number,
    right: number,
    renderOrderID: number,
    segments: Rectangle[],
    smoothed: boolean,
    top: number,
    type: number,
    transformCallback: Function,
    transformCallbackContext: any,
    scaleMin: Point,
    scaleMax: Point,
    updateAnimation: Function,
    world: Point,
    x: number,
    y: number,
    z: number,
    bringToTop(): Rope,
    checkTransform(wt: PIXI.Matrix): void,
    crop(rect: Rectangle, copy?: boolean): void,
    destroy(destroyChildren?: boolean): void,
    kill(): Rope,
    loadTexture(
      key: string | RenderTexture | BitmapData | Video | PIXI.Texture,
      frame?: string | number,
      stopAnimation?: boolean,
    ): void,
    moveUp(): Rope,
    moveDown(): Rope,
    play(
      name: string,
      frameRate?: number,
      loop?: boolean,
      killOnComplete?: boolean,
    ): Animation,
    preUpdate(): void,
    postUpdate(): void,
    reset(x: number, y: number, health?: number): Rope,
    resizeFrame(parent: any, width: number, height: number): void,
    resetFrame(): void,
    revive(health?: number): Rope,
    sendToBack(): Rope,
    setFrame(frame: Frame): void,
    setScaleMinMax(
      minX?: number,
      minY?: number,
      maxX?: number,
      maxY?: number,
    ): void,
    updateCrop(): void,
    update(): void,
  }

  declare class RoundedRectangle extends PIXI.RoundedRectangle {
    x: number,
    y: number,
    width: number,
    height: number,
    radius: number,
    type: number,
    clone(): RoundedRectangle,
    contains(x: number, y: number): boolean,
  }

  declare class Signal {
    active: boolean,
    boundDispatch: Function,
    memorize: boolean,
    add(
      listener: Function,
      listenerContext?: any,
      priority?: number,
      ...args: any[]
    ): SignalBinding,
    addOnce(
      listener: Function,
      listenerContext?: any,
      priority?: number,
      ...args: any[]
    ): SignalBinding,
    dispatch(...params: any[]): void,
    dispose(): void,
    forget(): void,
    getNumListeners(): number,
    halt(): void,
    has(listener: Function, context?: any): boolean,
    remove(listener: Function, context?: any): Function,
    removeAll(context?: any): void,
    toString(): string,
    validateListener(listener: Function, fnName: string): void,
  }

  declare class SignalBinding {
    constructor(
      signal: Signal,
      listener: Function,
      isOnce: boolean,
      listenerContext?: any,
      priority?: number,
      ...args: any[]
    ): this,
    active: boolean,
    callCount: number,
    context: any,
    params: any[],
    execute(paramsArr?: any[]): void,
    detach(): Function,
    isBound(): boolean,
    isOnce(): boolean,
    getListener(): Function,
    getSignal(): Signal,
    toString(): string,
  }

  declare class SinglePad {
    constructor(game: Game, padParent: any): this,
    callbackContext: any,
    connected: boolean,
    deadZone: number,
    game: Game,
    index: number,
    onAxisCallback: Function,
    onConnectCallback: Function,
    onDisconnectCallback: Function,
    onDownCallback: Function,
    onFloatCallback: Function,
    onUpCallback: Function,
    axis(axisCode: number): number,
    addCallbacks(context: any, callbacks: any): void,
    buttonValue(buttonCode: number): number,
    connect(rawPad: any): void,
    destroy(): void,
    disconnect(): void,
    getButton(buttonCode: number): DeviceButton,
    isDown(buttonCode: number): boolean,
    isUp(buttonCode: number): boolean,
    justPressed(buttonCode: number, duration?: number): boolean,
    justReleased(buttonCode: number, duration?: number): boolean,
    pollStatus(): void,
    processAxisChange(axisState: any): void,
    processButtonDown(buttonCode: number, value: any): void,
    processButtonFloat(buttonCode: number, value: any): void,
    processButtonUp(buttonCode: number, value: any): void,
    reset(): void,
  }

  declare class Sound {
    constructor(
      game: Game,
      key: string,
      volume?: number,
      loop?: boolean,
      connect?: boolean,
    ): this,
    autoplay: boolean,
    allowMultiple: boolean,
    context: any,
    currentMarker: string,
    currentTime: number,
    destroy(remove?: boolean): void,
    duration: number,
    durationMS: number,
    externalNode: any,
    fadeTween: Tween,
    game: Game,
    gainNode: any,
    isDecoded: boolean,
    isDecoding: boolean,
    isPlaying: boolean,
    key: string,
    loop: boolean,
    markers: any,
    masterGainNode: any,
    mute: boolean,
    name: string,
    onDecoded: Signal,
    onEndedHandler: () => void,
    onFadeComplete: Signal,
    onLoop: Signal,
    onMarkerComplete: Signal,
    onMute: Signal,
    onPause: Signal,
    onPlay: Signal,
    onResume: Signal,
    onStop: Signal,
    override: boolean,
    paused: boolean,
    pausedPosition: number,
    pausedTime: number,
    pendingPlayback: boolean,
    position: number,
    startTime: number,
    stopTime: number,
    totalDuration: number,
    usingAudioTag: boolean,
    usingWebAudio: boolean,
    volume: number,
    addMarker(
      name: string,
      start: number,
      duration: number,
      volume?: number,
      loop?: boolean,
    ): void,
    destroy(): void,
    fadeIn(duration?: number, loop?: boolean, marker?: string): void,
    fadeOut(duration?: number): void,
    fadeTo(duration?: number, volume?: number): void,
    loopFull(volume?: number): Sound,
    pause(): void,
    play(
      marker?: string,
      position?: number,
      volume?: number,
      loop?: boolean,
      forceRestart?: boolean,
    ): Sound,
    removeMarker(name: string): void,
    restart(
      marker: string,
      position: number,
      volume?: number,
      loop?: boolean,
    ): void,
    resume(): void,
    soundHasUnlocked(key: string): void,
    stop(): void,
    update(): void,
  }

  declare class SoundManager {
    constructor(game: Game): this,
    channels: number,
    connectToMaster: boolean,
    context: any,
    game: Game,
    mute: boolean,
    muteOnPause: boolean,
    noAudio: boolean,
    onSoundDecode: Signal,
    onVolumeChange: Signal,
    onMute: Signal,
    onUnMute: Signal,
    touchLocked: boolean,
    usingAudioTag: boolean,
    usingWebAudio: boolean,
    volume: number,
    add(key: string, volume?: number, loop?: boolean, connect?: boolean): Sound,
    addSprite(key: string): AudioSprite,
    boot(): void,
    decode(key: string, sound?: Sound): void,
    destroy(): void,
    pauseAll(): void,
    play(key: string, volume?: number, loop?: boolean): Sound,
    remove(sound: Sound): boolean,
    removeByKey(key: string): number,
    resumeAll(): void,
    setDecodedCallback(
      files: string[] | Sound[],
      callback: Function,
      callbackContext: any,
    ): void,
    setTouchLock(): void,
    stopAll(): void,
    unlock(): boolean,
    update(): void,
  }

  declare class Sprite extends PIXI.Sprite {
    constructor(
      game: Game,
      x: number,
      y: number,
      key?: string | RenderTexture | BitmapData | PIXI.Texture,
      frame?: string | number,
    ): this,
    alive: boolean,
    anchor: Point,
    angle: number,
    animations: AnimationManager,
    autoCull: boolean,
    body: Any$Body,
    bottom: number,
    cameraOffset: Point,
    centerX: number,
    centerY: number,
    checkWorldBounds: boolean,
    components: any,
    cropRect: Rectangle,
    customRender: boolean,
    data: any,
    debug: boolean,
    deltaX: number,
    deltaY: number,
    deltaZ: number,
    destroyPhase: boolean,
    events: Events,
    exists: boolean,
    fixedToCamera: boolean,
    frame: string | number,
    frameName: string,
    fresh: boolean,
    game: Game,
    health: number,
    inCamera: boolean,
    input: InputHandler,
    inputEnabled: boolean,
    inWorld: boolean,
    key: string | RenderTexture | BitmapData | Video | PIXI.Texture,
    left: number,
    lifespan: number,
    maxHealth: number,
    name: string,
    offsetX: number,
    offsetY: number,
    outOfBoundsKill: boolean,
    pendingDestroy: boolean,
    previousPosition: Point,
    previousRotation: number,
    position: Point,
    physicsEnabled: boolean,
    physicsType: number,
    renderOrderID: number,
    right: number,
    scale: Point,
    scaleMin: Point,
    scaleMax: Point,
    smoothed: boolean,
    top: number,
    type: number,
    tintedTexture: HTMLCanvasElement,
    transformCallback: Function,
    transformCallbackContext: any,
    world: Point,
    x: number,
    y: number,
    z: number,
    alignIn(
      container:
        | Rectangle
        | Sprite
        | Image
        | Text
        | BitmapText
        | Button
        | Graphics
        | TileSprite,
      position?: number,
      offsetX?: number,
      offsetY?: number,
    ): any,
    alignTo(
      container:
        | Rectangle
        | Sprite
        | Image
        | Text
        | BitmapText
        | Button
        | Graphics
        | TileSprite,
      position?: number,
      offsetX?: number,
      offsetY?: number,
    ): any,
    bringToTop(): Sprite,
    crop(rect: Rectangle, copy: boolean): void,
    checkTransform(wt: PIXI.Matrix): void,
    damage(amount: number): Sprite,
    destroy(destroyChildren?: boolean): void,
    drawPolygon(): void,
    heal(amount: number): Sprite,
    kill(): Sprite,
    loadTexture(
      key: string | RenderTexture | BitmapData | Video | PIXI.Texture,
      frame?: string | number,
      stopAnimation?: boolean,
    ): void,
    moveUp(): Sprite,
    moveDown(): Sprite,
    overlap(
      displayObject: Sprite | Image | TileSprite | Button | PIXI.DisplayObject,
    ): boolean,
    play(
      name: string,
      frameRate?: number,
      loop?: boolean,
      killOnComplete?: boolean,
    ): Animation,
    postUpdate(): void,
    preUpdate(): void,
    reset(x: number, y: number, health?: number): Sprite,
    resetFrame(): void,
    resizeFrame(parent: any, width: number, height: number): void,
    revive(health?: number): Sprite,
    sendToBack(): Sprite,
    setFrame(frame: Frame): void,
    setScaleMinMax(
      minX?: number,
      minY?: number,
      maxX?: number,
      maxY?: number,
    ): void,
    update(): void,
    updateCrop(): void,
  }

  declare class SpriteBatch extends Group {
    constructor(
      game: Game,
      parent: PIXI.DisplayObjectContainer,
      name?: string,
      addedToStage?: boolean,
    ): this,
    type: number,
  }

  declare class Stage extends PIXI.DisplayObjectContainer {
    constructor(game: Game): this,
    game: Game,
    name: string,
    disableVisibilityChange: boolean,
    exists: boolean,
    currentRenderOrderID: number,
    backgroundColor: any,
    smoothed: boolean,
    parseConfig(config: any): void,
    preUpdate(): void,
    update(): void,
    postUpdate(): void,
    updateTransform(): void,
    checkVisibility(): void,
    visibilityChange(event: Event): void,
    setBackgroundColor(backgroundColor: number | string): void,
    destroy(): void,
  }

  declare interface ResizeCallback {
    (scale: ScaleManager, parentBounds: Rectangle): any,
  }

  declare class ScaleManager {
    constructor(
      game: Game,
      width: number | string,
      height: number | string,
    ): this,
    EXACT_FIT: number,
    NO_SCALE: number,
    SHOW_ALL: number,
    RESIZE: number,
    USER_SCALE: number,
    aspectRatio: number,
    bounds: Rectangle,
    boundingParent: HTMLElement,
    compatibility: {
      canExpandParent: boolean,
      clickTrampoline: string,
      forceMinimumDocumentHeight: boolean,
      noMargins: boolean,
      orientationFallback: boolean,
      scrollTo: Point,
      supportsFullScreen: boolean,
    },
    currentScaleMode: number,
    dom: DOM,
    enterIncorrectOrientation: Signal,
    event: any,
    forceLandscape: boolean,
    forcePortrait: boolean,
    fullScreenScaleMode: number,
    fullScreenTarget: HTMLElement,
    game: Game,
    grid: FlexGrid,
    hasPhaserSetFullScreen: boolean,
    height: number,
    incorrectOrientation: boolean,
    isFullScreen: boolean,
    isGameLandscape: boolean,
    isGamePortrait: boolean,
    isPortrait: boolean,
    isLandscape: boolean,
    leaveIncorrectOrientation: Signal,
    margin: {
      left: number,
      top: number,
      right: number,
      bottom: number,
      x: number,
      y: number,
    },
    maxHeight: number,
    maxWidth: number,
    minHeight: number,
    minWidth: number,
    offset: Point,
    onFullScreenInit: Signal,
    onFullScreenChange: Signal,
    onFullScreenError: Signal,
    onOrientationChange: Signal,
    onSizeChange: Signal,
    pageAlignHorizontally: boolean,
    pageAlignVertically: boolean,
    parentNode: HTMLElement,
    parentIsWindow: boolean,
    parentScaleFactor: Point,
    scaleFactor: Point,
    scaleFactorInversed: Point,
    scaleMode: number,
    screenOrientation: string,
    sourceAspectRatio: number,
    trackParentInterval: number,
    width: number,
    windowConstraints: {
      bottom: string,
      right: string,
    },
    boot(): void,
    createFullScreenTarget(): HTMLDivElement,
    destroy(): void,
    forceOrientation(forceLandscape: boolean, forcePortrait?: boolean): void,
    getParentBounds(target?: Rectangle): Rectangle,
    parseConfig(config: any): void,
    preUpdate(): void,
    pauseUpdate(): void,
    refresh(): void,
    setGameSize(width: number, height: number): void,
    setResizeCallback(callback: ResizeCallback, context: any): void,
    setUserScale(
      hScale: number,
      vScale: number,
      hTrim?: number,
      vTrim?: number,
    ): void,
    setMinMax(
      minWidth: number,
      minHeight: number,
      maxWidth?: number,
      maxHeight?: number,
    ): void,
    setupScale(width: number, height: number): void,
    setupScale(width: string, height: string): void,
    scaleSprite(
      sprite: Sprite,
      width?: number,
      height?: number,
      letterBox?: boolean,
    ): Sprite,
    scaleSprite(
      sprite: Image,
      width?: number,
      height?: number,
      letterBox?: boolean,
    ): Sprite,
    startFullScreen(antialias?: boolean, allowTrampoline?: boolean): boolean,
    stopFullScreen(): boolean,
  }

  declare class DOM {
    visualBounds: Rectangle,
    layoutBounds: Rectangle,
    documentBounds: Rectangle,
    calibrate(coords: any, cushion?: number): any,
    getAspectRatio(object: any): number,
    getScreenOrientation(primaryFallback?: string): string,
    getBounds(element: any, cushion?: number): any,
    getOffset(element: any, point?: Point): Point,
    inLayoutViewport(element: any, cushion?: number): boolean,
  }

  declare class State {
    add: GameObjectFactory,
    cache: Cache,
    camera: Camera,
    game: Game,
    input: Input,
    key: string,
    load: Loader,
    make: GameObjectCreator,
    particles: Particles,
    physics: Physics,
    rnd: RandomDataGenerator,
    scale: ScaleManager,
    sound: SoundManager,
    stage: Stage,
    state: StateManager,
    time: Time,
    tweens: TweenManager,
    world: World,
    create(): void,
    init(...args: any[]): void,
    loadRender(): void,
    loadUpdate(): void,
    paused(): void,
    pauseUpdate(): void,
    preload(): void,
    preRender(): void,
    render(): void,
    resize(): void,
    resumed(): void,
    shutdown(): void,
    update(): void,
  }

  declare class StateManager {
    constructor(game: Game, pendingState?: State): this,
    created: boolean,
    current: string,
    game: Game,
    onCreateCallback: Function,
    onInitCallback: Function,
    onLoadRenderCallback: Function,
    onLoadUpdateCallback: Function,
    onPausedCallback: Function,
    onPauseUpdateCallback: Function,
    onPreloadCallback: Function,
    onPreRenderCallback: Function,
    onRenderCallback: Function,
    onResumedCallback: Function,
    onResizeCallback: Function,
    onShutDownCallback: Function,
    onUpdateCallback: Function,
    states: any,
    onStateChange: Signal,
    add(key: string, state: any, autoStart?: boolean): void,
    checkState(key: string): boolean,
    clearCurrentState(): void,
    destroy(): void,
    getCurrentState(): State,
    link(key: string): void,
    loadComplete(): void,
    preRender(elapsedTime: number): void,
    preUpdate(): void,
    render(): void,
    remove(key: string): void,
    resume(): void,
    restart(clearWorld?: boolean, clearCache?: boolean, ...args: any[]): void,
    resize(width: number, height: number): void,
    start(
      key: string,
      clearWorld?: boolean,
      clearCache?: boolean,
      ...args: any[]
    ): void,
    update(): void,
    unlink(key: string): void,
  }

  declare interface PhaserTextStyle {
    font?: string,
    fill?: any,
    align?: string,
    stroke?: string,
    strokeThickness?: number,
    wordWrap?: boolean,
    wordWrapWidth?: number,
    maxLines?: number,
    shadowOffsetX?: number,
    shadowOffsetY?: number,
    shadowColor?: string,
    shadowBlur?: number,
    valign?: string,
    tab?: number,
    tabs?: number,
    fontSize?: number,
    fontStyle?: string,
    fontVariant?: string,
    fontWeight?: string | number,
    backgroundColor?: string,
    boundsAlignH?: string,
    boundsAlignV?: string,
  }

  declare class Text extends Sprite {
    constructor(
      game: Game,
      x: number,
      y: number,
      text: string,
      style?: PhaserTextStyle,
    ): this,
    fontPropertiesCanvas: any,
    fontPropertiesContext: any,
    fontPropertiesCache: any,
    align: string,
    angle: number,
    autoRound: boolean,
    boundsAlignH: string,
    boundsAlignV: string,
    cameraOffset: Point,
    canvas: HTMLCanvasElement,
    colors: string[],
    context: CanvasRenderingContext2D,
    cssFont: string,
    destroyPhase: boolean,
    events: Events,
    exists: boolean,
    fill: any,
    fixedToCamera: boolean,
    font: string,
    fontSize: number | string,
    fontStyle: string,
    fontStyles: string[],
    fontVariant: string,
    fontWeight: string | number,
    fontWeights: string | number[],
    game: Game,
    input: InputHandler,
    inputEnabled: boolean,
    lineSpacing: number,
    name: string,
    padding: Point,
    pendingDestroy: boolean,
    physicsType: number,
    position: Point,
    previousPosition: Point,
    previousRotation: number,
    renderOrderID: number,
    resolution: number,
    shadowBlur: number,
    shadowColor: string,
    shadowFill: boolean,
    shadowOffsetX: number,
    shadowOffsetY: number,
    shadowStroke: boolean,
    splitRegExp: any,
    stroke: string,
    strokeColors: string[],
    strokeThickness: number,
    scale: Point,
    tab: number,
    tabs: number | number[],
    text: string,
    textBounds: Rectangle,
    type: number,
    useAdvancedWrap: boolean,
    world: Point,
    wordWrap: boolean,
    wordWrapWidth: number,
    z: number,
    addColor(color: string, position: number): Text,
    addFontStyle(style: string, position: number): Text,
    addFontWeight(weight: string, position: number): Text,
    addStrokeColor(color: string, position: number): Text,
    alignIn(
      container:
        | Rectangle
        | Sprite
        | Image
        | Text
        | BitmapText
        | Button
        | Graphics
        | TileSprite,
      position?: number,
      offsetX?: number,
      offsetY?: number,
    ): any,
    alignTo(
      container:
        | Rectangle
        | Sprite
        | Image
        | Text
        | BitmapText
        | Button
        | Graphics
        | TileSprite,
      position?: number,
      offsetX?: number,
      offsetY?: number,
    ): any,
    clearColors(): Text,
    clearFontValues(): Text,
    componentsToFont(components: any): string,
    destroy(destroyChildren?: boolean): void,
    fontToComponents(font: string): any,
    postUpdate(): void,
    parseList(list: any[]): Text,
    precalculateWordWrap(text: string): string[],
    preUpdate(): void,
    renderTabLine(line: string, x: number, y: number, fill?: boolean): void,
    setShadow(
      x?: number,
      y?: number,
      color?: any,
      blur?: number,
      shadowStroke?: boolean,
      shadowFill?: boolean,
    ): Text,
    setStyle(style?: PhaserTextStyle, update?: boolean): Text,
    setText(text: string, immediate?: boolean): Text,
    setTextBounds(
      x?: number,
      y?: number,
      width?: number,
      height?: number,
    ): Text,
    update(): void,
    updateFont(components: any): void,
    updateLine(text: string, x?: number, y?: number): void,
    updateShadow(state?: boolean): void,
    updateTexture(): void,
  }

  declare class Tile {
    constructor(
      layer: any,
      index: number,
      x: number,
      y: Number,
      width: number,
      height: number,
    ): this,
    alpha: number,
    bottom: number,
    callback: Function,
    callbackContext: any,
    centerX: number,
    centerY: number,
    canCollide: boolean,
    collideDown: boolean,
    collideLeft: boolean,
    collideNone: boolean,
    collideRight: boolean,
    collisionCallback: Function,
    collisionCallbackContext: any,
    collides: boolean,
    collideUp: boolean,
    faceBottom: boolean,
    faceLeft: boolean,
    faceRight: boolean,
    faceTop: boolean,
    game: Game,
    height: number,
    index: number,
    layer: any,
    left: number,
    properties: any,
    right: number,
    scanned: boolean,
    top: number,
    width: number,
    worldX: number,
    worldY: number,
    x: number,
    y: number,
    copy(tile: Tile): Tile,
    containsPoint(x: number, y: number): boolean,
    destroy(): void,
    intersects(x: number, y: number, right: number, bottom: number): boolean,
    isInterested(collides: boolean, faces: boolean): boolean,
    resetCollision(): void,
    setCollision(
      left: boolean,
      right: boolean,
      up: boolean,
      down: boolean,
    ): void,
    setCollisionCallback(callback: Function, context: any): void,
  }

  declare class Tilemap {
    constructor(
      game: Game,
      key?: string,
      tileWidth?: number,
      tileHeight?: number,
      width?: number,
      height?: number,
    ): this,
    CSV: number,
    TILED_JSON: number,
    NORTH: number,
    EAST: number,
    SOUTH: number,
    WEST: number,
    collision: any[],
    collideIndexes: any[],
    currentLayer: number,
    debugMap: any[],
    enableDebug: boolean,
    format: number,
    game: Game,
    height: number,
    heightInPixels: number,
    images: any[],
    imagecollections: ImageCollection[],
    key: string,
    layer: TilemapLayer[],
    layers: any[],
    objects: any[],
    orientation: string,
    properties: any,
    rayStepRate: number,
    tileHeight: number,
    tiles: Tile[],
    tilesets: Tileset[],
    tileWidth: number,
    version: number,
    width: number,
    widthInPixels: number,
    addTilesetImage(
      tileset: string,
      key?: string | BitmapData,
      tileWidth?: number,
      tileHeight?: number,
      tileMargin?: number,
      tileSpacing?: number,
      gid?: number,
    ): Tileset,
    calculateFaces(layer: number): void,
    copy(
      x: number,
      y: number,
      width: number,
      height: number,
      layer?: any,
    ): Tile[],
    create(
      name: string,
      width: number,
      height: number,
      tileWidth: number,
      tileHeight: number,
      group?: Group,
    ): TilemapLayer,
    createBlankLayer(
      name: string,
      width: number,
      height: number,
      tileWidth: number,
      tileHeight: number,
      group?: Group,
    ): TilemapLayer,
    createFromObjects(
      name: string,
      gid: number,
      key: string,
      frame?: any,
      exists?: boolean,
      autoCull?: boolean,
      group?: Group,
      CustomClass?: any,
      adjustY?: boolean,
    ): void,
    createFromTiles(
      tiles: any,
      replacements: any,
      key: string,
      layer?: any,
      group?: Group,
      properties?: any,
    ): number,
    createLayer(
      layer: any,
      width?: number,
      height?: number,
      group?: Group,
    ): TilemapLayer,
    destroy(): void,
    dump(): void,
    fill(
      index: number,
      x: number,
      y: number,
      width: number,
      height: number,
      layer?: any,
    ): void,
    forEach(
      callback: Function,
      context: any,
      x: number,
      y: Number,
      width: number,
      height: number,
      layer?: any,
    ): void,
    getImageIndex(name: string): number,
    getIndex(location: any[], name: string): number,
    getLayer(layer: any): number,
    getLayerIndex(name: string): number,
    getObjectIndex(name: string): number,
    getTile(x: number, y: number, layer?: any, nonNull?: boolean): Tile,
    getTileAbove(layer: number, x: number, y: number): Tile,
    getTileBelow(layer: number, x: number, y: number): Tile,
    getTileLeft(layer: number, x: number, y: number): Tile,
    getTileRight(layer: number, x: number, y: number): Tile,
    getTilesetIndex(name: string): number,
    getTileWorldXY(
      x: number,
      y: number,
      tileWidth?: number,
      tileHeight?: number,
      layer?: number | string | TilemapLayer,
      nonNull?: boolean,
    ): Tile,
    hasTile(x: number, y: number, layer: TilemapLayer): boolean,
    paste(x: number, y: number, tileblock: Tile[], layer?: any): void,
    putTile(tile: any, x: number, y: number, layer?: any): Tile,
    putTileWorldXY(
      tile: any,
      x: number,
      y: number,
      tileWidth: number,
      tileHeight: number,
      layer?: any,
    ): void,
    random(
      x: number,
      y: number,
      width: number,
      height: number,
      layer?: any,
    ): void,
    removeAllLayers(): void,
    removeTile(x: number, y: number, layer?: any): Tile,
    removeTileWorldXY(
      x: number,
      y: number,
      tileWidth: number,
      tileHeight: number,
      layer?: any,
    ): Tile,
    replace(
      source: number,
      dest: number,
      x: number,
      y: number,
      width: number,
      height: number,
      layer?: any,
    ): void,
    searchTileIndex(
      index: number,
      skip?: number,
      reverse?: boolean,
      layer?: any,
    ): Tile,
    setCollision(
      indexes: any,
      collides?: boolean,
      layer?: any,
      recalculate?: boolean,
    ): void,
    setCollisionBetween(
      start: number,
      stop: number,
      collides?: boolean,
      layer?: any,
      recalculate?: boolean,
    ): void,
    setCollisionByExclusion(
      indexes: any[],
      collides?: boolean,
      layer?: any,
      recalculate?: boolean,
    ): void,
    setCollisionByIndex(
      index: number,
      collides?: boolean,
      layer?: number,
      recalculate?: boolean,
    ): void,
    setLayer(layer: any): void,
    setPreventRecalculate(value: boolean): void,
    setTileIndexCallback(
      indexes: any,
      callback: Function,
      callbackContext: any,
      layer?: any,
    ): void,
    setTileLocationCallback(
      x: number,
      y: number,
      width: number,
      height: number,
      callback: Function,
      callbackContext: any,
      layer?: any,
    ): void,
    setTileSize(tileWidth: number, tileHeight: number): void,
    shuffle(
      x: number,
      y: number,
      width: number,
      height: number,
      layer: any,
    ): void,
    swap(
      tileA: number,
      tileB: number,
      x: number,
      y: number,
      width: number,
      height: number,
      layer?: any,
    ): void,
  }

  declare class TilemapLayer extends Sprite {
    constructor(
      game: Game,
      tilemap: Tilemap,
      index: number,
      width?: number,
      height?: number,
    ): this,
    cameraOffset: Point,
    canvas: HTMLCanvasElement,
    collisionHeight: number,
    collisionWidth: number,
    context: CanvasRenderingContext2D,
    data: any,
    debug: boolean,
    debugAlpha: number,
    debugCallbackColor: string,
    debugColor: string,
    debugSettings: {
      missingImageFill: string,
      debuggedTileOverfill: string,
      forceFullRedraw: boolean,
      debugAlpha: number,
      facingEdgeStroke: string,
      collidingTileOverfill: string,
    },
    dirty: boolean,
    exists: boolean,
    fixedToCamera: boolean,
    game: Game,
    index: number,
    layer: TilemapLayer,
    map: Tilemap,
    name: string,
    physicsType: number,
    renderSettings: {
      enableScrollDelta: boolean,
      overdrawRatio: number,
      copyCanvas: any,
    },
    scrollFactorX: number,
    scrollFactorY: number,
    scrollX: number,
    scrollY: number,
    type: number,
    wrap: boolean,
    destroy(): void,
    getRayCastTiles(
      layer: TilemapLayer | TilemapLayerGL,
      line: Line,
      stepRate?: number,
      collides?: boolean,
      interestingFace?: boolean,
    ): Tile[],
    getTiles(
      layer: TilemapLayer | TilemapLayerGL,
      x: number,
      y: number,
      width: number,
      height: number,
      collides?: boolean,
      interestingFace?: boolean,
    ): Tile[],
    getTileX(layer: TilemapLayer | TilemapLayerGL, x: number): number,
    getTileXY(
      layer: TilemapLayer | TilemapLayerGL,
      x: number,
      y: number,
      point: Point,
    ): Point,
    getTileY(layer: TilemapLayer | TilemapLayerGL, y: number): number,
    postUpdate(): void,
    render(): void,
    resize(width: number, height: number): void,
    resizeWorld(): void,
    resetTilesetCache(): void,
    setScale(xScale?: number, yScale?: number): void,
    updateMax(): void,
  }

  declare class TilemapLayerGL {
    constructor(
      game: Game,
      tilemap: Tilemap,
      index: number,
      width?: number,
      height?: number,
      tileset?: Tileset,
    ): this,
    collisionHeight: number,
    collisionWidth: number,
    data: any,
    dirty: boolean,
    exists: boolean,
    fixedToCamera: boolean,
    game: Game,
    index: number,
    layer: TilemapLayer,
    map: Tilemap,
    name: string,
    physicsType: number,
    scrollFactorX: number,
    scrollFactorY: number,
    scrollX: number,
    scrollY: number,
    type: number,
    wrap: boolean,
    x: number,
    y: number,
    width: number,
    height: number,
    destroy(): void,
    postUpdate(): void,
    render(): void,
    resize(width: number, height: number): void,
    resizeWorld(): void,
    resetTilesetCache(): void,
    setScale(xScale?: number, yScale?: number): void,
    updateMax(): void,
  }

  declare class TilemapParser {
    INSERT_NULL: boolean,
    getEmptyData(
      tileWidth?: number,
      tileHeight?: number,
      width?: number,
      height?: number,
    ): any,
    parse(
      game: Game,
      key: string,
      tileWidth?: number,
      tileHeight?: number,
      width?: number,
      height?: number,
    ): any,
    parseCSV(
      key: string,
      data: string,
      tileWidth?: number,
      tileHeight?: number,
    ): any,
    parseJSON(json: any): any,
  }

  declare class Tileset {
    constructor(
      name: string,
      firstgid: number,
      width?: number,
      height?: number,
      margin?: number,
      spacing?: number,
      properties?: any,
    ): this,
    columns: number,
    firstgid: number,
    image: any,
    lastgid: number,
    name: string,
    properties: any,
    rows: number,
    tileHeight: number,
    tileMargin: number,
    tileSpacing: number,
    tileWidth: number,
    total: number,
    containsTileIndex(tileIndex: number): boolean,
    draw(
      context: CanvasRenderingContext2D,
      x: number,
      y: number,
      index: number,
    ): void,
    drawGl(
      glBatch: any[],
      x: number,
      y: number,
      index: number,
      alpha: number,
      flippedVal: number,
    ): void,
    setImage(image: any): void,
    setSpacing(margin?: number, spacing?: number): void,
  }

  declare class TileSprite extends PIXI.TilingSprite {
    constructor(
      game: Game,
      x: number,
      y: number,
      width: number,
      height: number,
      key?: string | RenderTexture | BitmapData | PIXI.Texture,
      frame?: string | number,
    ): this,
    alive: boolean,
    angle: number,
    animations: AnimationManager,
    autoCull: boolean,
    body: Any$Body,
    bottom: number,
    cameraOffset: Point,
    checkWorldBounds: boolean,
    components: any,
    customRender: boolean,
    data: any,
    debug: boolean,
    destroyPhase: boolean,
    events: Events,
    exists: boolean,
    fixedToCamera: boolean,
    frame: string | number,
    frameName: string,
    fresh: boolean,
    game: Game,
    inCamera: boolean,
    input: InputHandler,
    inputEnabled: boolean,
    inWorld: boolean,
    key: string | RenderTexture | BitmapData | Video | PIXI.Texture,
    left: number,
    name: string,
    offsetX: number,
    offsetY: number,
    outOfBoundsKill: boolean,
    pendingDestroy: boolean,
    physicsType: number,
    position: Point,
    smoothed: boolean,
    previousPosition: Point,
    previousRoation: number,
    right: number,
    top: number,
    renderOrderID: number,
    type: number,
    world: Point,
    z: number,
    alignIn(
      container:
        | Rectangle
        | Sprite
        | Image
        | Text
        | BitmapText
        | Button
        | Graphics
        | TileSprite,
      position?: number,
      offsetX?: number,
      offsetY?: number,
    ): any,
    alignTo(
      container:
        | Rectangle
        | Sprite
        | Image
        | Text
        | BitmapText
        | Button
        | Graphics
        | TileSprite,
      position?: number,
      offsetX?: number,
      offsetY?: number,
    ): any,
    autoScroll(x: number, y: number): void,
    destroy(destroyChildren?: boolean): void,
    loadTexture(
      key: string | RenderTexture | BitmapData | Video | PIXI.Texture,
      frame?: string | number,
      stopAnimation?: boolean,
    ): void,
    play(
      name: string,
      frameRate?: number,
      loop?: boolean,
      killOnComplete?: boolean,
    ): Animation,
    postUpdate(): void,
    preUpdate(): void,
    overlap(
      displayObject: Sprite | Image | TileSprite | Button | PIXI.DisplayObject,
    ): boolean,
    reset(x: number, y: number, health?: number): TileSprite,
    resizeFrame(parent: any, width: number, height: number): void,
    resetFrame(): void,
    setFrame(frame: Frame): void,
    stopScroll(): void,
    update(): void,
  }

  declare class Time {
    constructor(game: Game): this,
    advancedTiming: boolean,
    desiredFps: number,
    desiredFpsMult: number,
    elapsed: number,
    events: Timer,
    elapsedMS: number,
    fps: number,
    fpsMax: number,
    fpsMin: number,
    frames: number,
    game: Game,
    lastTime: number,
    msMax: number,
    msMin: number,
    now: number,
    pausedTime: number,
    pauseDuration: number,
    physicsElapsed: number,
    physicsElapsedMS: number,
    prevTime: number,
    slowMotion: number,
    suggestedFps: number,
    time: number,
    timeExpected: number,
    timeToCall: number,
    add(timer: Timer): Timer,
    boot(): void,
    create(autoDestroy?: boolean): Timer,
    elapsedSecondsSince(since: number): number,
    elapsedSince(since: number): number,
    removeAll(): void,
    reset(): void,
    totalElapsedSeconds(): number,
    update(time: number): void,
  }

  declare class Timer {
    constructor(game: Game, autoDestroy?: boolean): this,
    HALF: number,
    MINUTE: number,
    QUARTER: number,
    SECOND: number,
    autoDestroy: boolean,
    duration: number,
    events: TimerEvent[],
    expired: boolean,
    game: Game,
    length: number,
    ms: number,
    next: number,
    nextTick: number,
    onComplete: Signal,
    running: boolean,
    paused: boolean,
    seconds: number,
    add(
      delay: number,
      callback: Function,
      callbackContext?: any,
      ...args: any[]
    ): TimerEvent,
    clearPendingEvents(): void,
    destroy(): void,
    loop(
      delay: number,
      callback: Function,
      callbackContext?: any,
      ...args: any[]
    ): TimerEvent,
    order(): void,
    pause(): void,
    remove(event: TimerEvent): boolean,
    removeAll(): void,
    repeat(
      delay: number,
      repeatCount: number,
      callback: Function,
      callbackContext?: any,
      ...args: any[]
    ): TimerEvent,
    resume(): void,
    sortHandler(a: any, b: any): number,
    start(startDelay?: number): void,
    stop(clearEvents?: boolean): void,
    update(time: number): boolean,
  }

  declare class TimerEvent {
    constructor(
      timer: Timer,
      delay: number,
      tick: number,
      repeatCount: number,
      loop: boolean,
      callback: Function,
      callbackContext: any,
      ...args: any[]
    ): this,
    args: any[],
    callback: Function,
    callbackContext: any,
    delay: number,
    loop: boolean,
    pendingDelete: boolean,
    repeatCount: number,
    tick: number,
    timer: Timer,
  }

  declare class Touch {
    constructor(game: Game): this,
    callbackContext: any,
    enabled: boolean,
    event: any,
    game: Game,
    preventDefault: boolean,
    touchCancelCallback: Function,
    touchEndCallback: Function,
    touchEnterCallback: Function,
    touchLeaveCallback: Function,
    touchMoveCallback: Function,
    touchStartCallback: Function,
    touchLockCallbacks: Function[],
    addTouchLockCallback(
      callback: Function,
      context?: any,
      onEnd?: Function,
    ): void,
    removeTouchLockCallback(callback: Function, context?: any): boolean,
    consumeTouchMove(): void,
    onTouchCancel(event: any): void,
    onTouchEnd(event: any): void,
    onTouchEnter(event: any): void,
    onTouchLeave(event: any): void,
    onTouchMove(event: any): void,
    onTouchStart(event: any): void,
    start(): void,
    stop(): void,
  }

  declare class Tween {
    constructor(target: any, game: Game, manager: TweenManager): this,
    chainedTween: Tween,
    current: number,
    frameBased: boolean,
    game: Game,
    isRunning: boolean,
    isPaused: boolean,
    manager: TweenManager,
    onChildComplete: Signal,
    onComplete: Signal,
    onLoop: Signal,
    onRepeat: Signal,
    onStart: Signal,
    pendingDelete: boolean,
    properties: any,
    repeatCounter: number,
    reverse: boolean,
    target: any,
    timeline: TweenData[],
    timeScale: number,
    totalDuration: number,
    chain(...args: any[]): Tween,
    delay(duration: number, index?: number): Tween,
    easing(ease: Function, index?: number): Tween,
    easing(ease: string, index?: number): Tween,
    from(
      properties: any,
      duration?: number,
      ease?: Function,
      autoStart?: boolean,
      delay?: number,
      repeat?: number,
      yoyo?: boolean,
    ): Tween,
    from(
      properties: any,
      duration?: number,
      ease?: string,
      autoStart?: boolean,
      delay?: number,
      repeat?: number,
      yoyo?: boolean,
    ): Tween,
    generateData(frameRate?: number, data?: any): any[],
    interpolation(
      interpolation: Function,
      context?: any,
      index?: number,
    ): Tween,
    loop(value?: boolean): Tween,
    onUpdateCallback(callback: Function, callbackContext?: any): Tween,
    pause(): void,
    repeat(total: number, repeatDelay?: number, index?: number): Tween,
    repeatDelay(duration: number, index?: number): Tween,
    repeatAll(total?: number): Tween,
    resume(): void,
    start(index?: number): Tween,
    stop(complete?: boolean): Tween,
    to(
      properties: any,
      duration?: number,
      ease?: Function,
      autoStart?: boolean,
      delay?: number,
      repeat?: number,
      yoyo?: boolean,
    ): Tween,
    to(
      properties: any,
      duration?: number,
      ease?: string,
      autoStart?: boolean,
      delay?: number,
      repeat?: number,
      yoyo?: boolean,
    ): Tween,
    update(time: number): boolean,
    updateTweenData(
      property: string,
      value: number | Function,
      index?: number,
    ): Tween,
    yoyo(enable: boolean, yoyoDelay?: number, index?: number): Tween,
    yoyoDelay(duration: number, index?: number): Tween,
  }

  declare class TweenData {
    constructor(parent: Tween): this,
    COMPLETE: number,
    LOOPED: number,
    PENDING: number,
    RUNNING: number,
    delay: number,
    dt: number,
    duration: number,
    easingFunction: Function,
    game: Game,
    inReverse: boolean,
    interpolate: boolean,
    interpolateFunctionContext: Math,
    interpolationContext: Math,
    interpolationFunction: Function,
    isRunning: boolean,
    isFrom: boolean,
    parent: Tween,
    percent: number,
    repeatCounter: number,
    startTime: number,
    value: number,
    yoyo: boolean,
    yoyoDelay: number,
    from(
      properties: any,
      duration?: number,
      ease?: Function,
      delay?: number,
      repeat?: number,
      yoyo?: boolean,
    ): TweenData,
    generateData(frameRate?: number): any[],
    repeat(): number,
    start(): TweenData,
    to(
      properties: any,
      duration?: number,
      ease?: Function,
      delay?: number,
      repeat?: number,
      yoyo?: boolean,
    ): TweenData,
    update(time: number): number,
  }

  declare class TweenManager {
    constructor(game: Game): this,
    frameBased: boolean,
    game: Game,
    add(tween: Tween): Tween,
    create(object: any): Tween,
    getAll(): Tween[],
    isTweening(object: any): boolean,
    remove(tween: Tween): Tween,
    removeAll(): void,
    removeFrom(obj: any, children?: boolean): void,
    resumeAll(): void,
    update(): boolean,
    pauseAll(): void,
  }

  declare class Utils {
    getProperty(obj: any, prop: string): any,
    setProperty(obj: any, prop: string, value: any): any,
    chanceRoll(chance: number): boolean,
    randomChoice(choice1: string | number, choice2: any): any,
    reverseString(string: string): string,
    parseDimension(size: any, dimension: number): number,
    pad(str: string, len?: number, pad?: string, dir?: number): string,
    isPlainObject(object: any): boolean,
    extend(deep: boolean, target: any, ...args: any[]): any,
    mixinPrototype(target: any, mixin: any, replace?: boolean): void,
    mixin<T>(from: T, to: any): T,
  }

  declare class Utils$Debug {
    constructor(game: Game): this,
    bmd: BitmapData,
    canvas: HTMLCanvasElement,
    columnWidth: number,
    context: CanvasRenderingContext2D,
    currentAlpha: number,
    currentX: number,
    currentY: number,
    dirty: boolean,
    font: string,
    game: Game,
    lineHeight: number,
    renderShadow: boolean,
    sprite: Image,
    AStar(
      astar: Plugin$AStar,
      x: number,
      y: number,
      showVisited: boolean,
    ): void,
    boot(): void,
    body(sprite: Sprite, color?: string, filled?: boolean): void,
    bodyInfo(sprite: Sprite, x: number, y: Number, color?: string): void,
    box2dBody(body: Sprite, color?: string): void,
    box2dWorld(): void,
    cameraInfo(camera: Camera, x: number, y: number, color?: string): void,
    destroy(): void,
    geom(
      object: any,
      color?: string,
      fiiled?: boolean,
      forceType?: number,
    ): void,
    inputInfo(x: number, y: number, color?: string): void,
    lineInfo(line: Line, x: number, y: number, color?: string): void,
    key(key: Key, x?: number, y?: number, color?: string): void,
    line(...args: string[]): void,
    preUpdate(): void,
    pixel(x: number, y: number, color?: string, size?: number): void,
    pointer(
      pointer: Pointer,
      hideIfUp?: boolean,
      downColor?: string,
      upColor?: string,
      color?: string,
    ): void,
    quadTree(quadtree: QuadTree, color?: string): void,
    rectangle(object: Rectangle, color?: string, filled?: boolean): void,
    reset(): void,
    ropeSegments(rope: Rope, color?: number, filled?: boolean): void,
    soundInfo(sound: Sound, x: number, y: number, color?: string): void,
    spriteBounds(sprite: any, color?: string, filled?: boolean): void,
    spriteCoords(sprite: any, x: number, y: number, color?: string): void,
    spriteInfo(sprite: Sprite, x: number, y: number, color?: string): void,
    spriteInputInfo(sprite: Sprite, x: number, y: number, color?: string): void,
    start(x?: number, y?: number, color?: string, columnWidth?: number): void,
    stop(): void,
    text(
      text: string,
      x: number,
      y: number,
      color?: string,
      font?: string,
    ): void,
    timer(timer: Timer, x: number, y: number, color?: string): void,
  }

  declare class Weapon extends Plugin {
    constructor(game: Game, parent: PluginManager): this,
    KILL_NEVER: number,
    KILL_LIFESPAN: number,
    KILL_DISTANCE: number,
    KILL_WEAPON_BOUNDS: number,
    KILL_CAMERA_BOUNDS: number,
    KILL_WORLD_BOUNDS: number,
    KILL_STATIC_BOUNDS: number,
    autoExpandBulletsGroup: boolean,
    autofire: boolean,
    bounds: Rectangle,
    bulletAngleOffset: number,
    bulletAngleVariance: number,
    bulletAnimation: string,
    bulletClass: any,
    bulletCollideWorldBounds: boolean,
    bulletFrame: string,
    bulletFrameCycle: boolean,
    bulletFrameRandom: boolean,
    bulletFrames: any[],
    bulletGravity: Point,
    bulletInheritSpriteSpeed: boolean,
    bulletKey: string,
    bulletKillDistance: number,
    bulletKillType: number,
    bulletLifespan: number,
    bulletRotateToVelocity: boolean,
    bullets: Group,
    bulletSpeed: number,
    bulletSpeedVariance: number,
    bulletWorldWrap: boolean,
    bulletWorldWrapPadding: number,
    fireAngle: number,
    fireFrom: Rectangle,
    fireLimit: number,
    fireRate: number,
    fireRateVariance: number,
    multiFire: boolean,
    onFire: Signal,
    onFireLimit: Signal,
    onKill: Signal,
    shots: number,
    trackedPointer: Pointer,
    trackedSprite: any,
    trackOffset: Point,
    trackRotation: boolean,
    x: number,
    y: number,
    addBulletAnimation(
      name: string,
      frames?: number[] | string[],
      frameRate?: number,
      loop?: boolean,
      useNumericIndex?: boolean,
    ): Weapon,
    createBullets(
      quantity?: number,
      key?: any,
      frame?: any,
      group?: Group,
    ): Weapon,
    debug(x?: number, y?: number, debugBodies?: boolean): void,
    destroy(): void,
    fire(
      from?: any,
      x?: number,
      y?: number,
      offsetX?: number,
      offsetY?: number,
    ): Bullet,
    fireAtPointer(pointer: Pointer): Bullet,
    fireAtSprite(sprite: Sprite): Bullet,
    fireAtXY(x: number, y: number): Bullet,
    fireMany(positions: any[], from?: any): Bullet[],
    fireOffset(offsetX?: number, offsetY?: number): Bullet,
    forEach(callback: any, callbackContext: any): Weapon,
    killAll(): Weapon,
    pauseAll(): Weapon,
    resetShots(newLimit?: number): Weapon,
    resumeAll(): Weapon,
    setBulletBodyOffset(
      width: number,
      height: number,
      offsetX?: number,
      offsetY?: number,
    ): Weapon,
    setBulletFrames(
      min: number,
      max: number,
      cycle?: boolean,
      random?: boolean,
    ): Weapon,
    trackPointer(pointer: Pointer, offsetX?: number, offsetY?: number): Weapon,
    trackSprite(
      sprite: Sprite,
      offsetX?: number,
      offsetY?: number,
      trackRotation?: boolean,
    ): Weapon,
  }

  declare class World extends Group {
    constructor(game: Game): this,
    bounds: Rectangle,
    camera: Camera,
    centerX: number,
    centerY: number,
    game: Game,
    height: number,
    isPaused: boolean,
    randomX: number,
    randomY: number,
    stats: {
      skipped: number,
      ignored: number,
      checked: number,
    },
    width: number,
    boot(): void,
    getObjectsUnderPointer(
      pointer: Pointer,
      group: Group,
      callback?: Function,
      callbackContext?: any,
    ): Sprite,
    resize(width: number, height: number): void,
    setBounds(x: number, y: number, width: number, height: number): void,
    sortLeftRight(a: Sprite, b: Sprite): number,
    sortRightLeft(a: Sprite, b: Sprite): number,
    sortTopBottom(a: Sprite, b: Sprite): number,
    sortBottomTop(a: Sprite, b: Sprite): number,
    sort(group: Group, sortDirection?: number): void,
    sort(key?: string, order?: number): void,
    shutdown(): void,
    wrap(
      sprite: any,
      padding?: number,
      useBounds?: boolean,
      horizontal?: boolean,
      vertical?: boolean,
    ): void,
  }
  declare var Easing: $Exports<'Easing'>;
}
declare module Easing {
  declare var Default: Function;
  declare var Power0: Function;
  declare var Power1: Function;
  declare var power2: Function;
  declare var power3: Function;
  declare var power4: Function;

  declare class Back {
    static In(k: number): number,
    static Out(k: number): number,
    static InOut(k: number): number,
  }

  declare class Bounce {
    static In(k: number): number,
    static Out(k: number): number,
    static InOut(k: number): number,
  }

  declare class Circular {
    static In(k: number): number,
    static Out(k: number): number,
    static InOut(k: number): number,
  }

  declare class Cubic {
    static In(k: number): number,
    static Out(k: number): number,
    static InOut(k: number): number,
  }

  declare class Elastic {
    static In(k: number): number,
    static Out(k: number): number,
    static InOut(k: number): number,
  }

  declare class Exponential {
    static In(k: number): number,
    static Out(k: number): number,
    static InOut(k: number): number,
  }

  declare class Linear {
    static None(k: number): number,
  }

  declare class Quadratic {
    static In(k: number): number,
    static Out(k: number): number,
    static InOut(k: number): number,
  }

  declare class Quartic {
    static In(k: number): number,
    static Out(k: number): number,
    static InOut(k: number): number,
  }

  declare class Quintic {
    static In(k: number): number,
    static Out(k: number): number,
    static InOut(k: number): number,
  }

  declare class Sinusoidal {
    static In(k: number): number,
    static Out(k: number): number,
    static InOut(k: number): number,
  }
}
